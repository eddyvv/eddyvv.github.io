<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux命令-rxe_cfg</title>
    <link href="/2023/09/07/Linux%E5%91%BD%E4%BB%A4-rxe_cfg/"/>
    <url>/2023/09/07/Linux%E5%91%BD%E4%BB%A4-rxe_cfg/</url>
    
    <content type="html"><![CDATA[<h1 id="rxe-cfg"><a href="#rxe-cfg" class="headerlink" title="rxe_cfg"></a>rxe_cfg</h1><p>rxe_cfg 是一个用于配置和管理 RXE（RDMA over Converged Ethernet）实例的命令行工具。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rxe_cfg [status]显示可用的以太网设备和配置的 RXE 实例的信息。<br>$ rxe_cfg start [-p proto]加载 RXE 模块并配置任何持久实例。<br>$ rxe_cfg stop取消配置所有的 RXE 实例并尝试卸载内核模块。<br>$ rxe_cfg persistent显示已持久配置的以太网设备列表。<br>$ rxe_cfg add [-n] ethN在以太网设备 ethN 上配置一个 RXE 实例。<br>$ rxe_cfg remove [-n] ethN|rxeN移除指定的 RXE 实例。<br>$ rxe_cfg crc <span class="hljs-built_in">enable</span>|<span class="hljs-built_in">disable</span>启用或禁用 RoCE ICRC计算。<br>$ rxe_cfg mtu [-f] [rxeN] mtu_size将所有 RXE 设备的 RoCE MTU 设置为 mtu_size。<br></code></pre></td></tr></table></figure><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">proto<br>以太类型字段。默认值为0x8915。必须更改此值才能在Mellanox ConnectX适配器上使用RXE。<br>ethN<br>/sys/class/net 中列出的网络设备名称。 仅支持以太网设备； IE. VLAN 的eth0或eth0.1234。<br>rxeN<br>/sys/class/infiniband/ 中列出的RXE设备名称。 例如 rxe0 或 rxe1。<br>mtu_size<br>RoCE mtu。 对于 RoCE，mtu表示不包括标头的有效负载，可能的值有：256、512、1024、2048 和 4096。<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">[status]<br>状态命令打印有关可用以太网设备和配置的 RXE 实例的信息表。 如果未提供任何选项，则状态显示为默 认值。<br>start [-p proto]<br>start命令加载 RXE 模块并配置任何持久实例。 如果包含 -p proto 选项，RXE 模块将配置为使用  Ethertype = proto。 （这允许在设备上测试 RXE，例如 Mellanox ConnectX，这些设备已经在硬件中支持默认的 RoCE 以太网类型。）<br>stop<br>stop 命令取消所有 RXE 实例的配置并尝试卸载内核模块。<br>persistent<br>显示已持久配置的以太网设备列表。<br>add [-n] ethN<br>add 命令将在以太网设备 ethN（例如 eth0）上配置 RXE 实例。<br>RXE 模块必须已通过 rxe_cfg start 加载。<br><br>默认行为是将 ethN 添加到持久配置文件中，并且下次运行 rxe_cfg start 时将配置相同的 RXE 设 备。 如果包含 -n 选项，则设备不会添加到持久性文件中。<br>remove [-n] ethN|rxeN<br>删除命令将删除指定的 RXE 实例。 该参数必须与当前活动的 ethN 或 rxeN 名称匹配。<br><br>如果包含 -n 选项，RXE 设备将被删除，但不会从持久状态中删除。 因此，下次运行 rxe_cfg start  时将重新创建它。<br>mtu [-f] [rxeN] mtu_size<br>mtu 命令会将所有 RXE 设备的 RoCE MTU 设置为 mtu_size，前提是底层以太网 MTU 足够大。 如果以太网MTU不够大，RXE将使用适合的最大MTU； 驱动程序会记住请求的 RoCE MTU，并且如果以太网    MTU 稍后更改为请求的 MTU，则会增加当前活动的 MTU。<br><br>如果包含 -f 选项，则基础以太网 MTU 将在必要时增加到最小大小，以适应 RoCE MTU 的大小。<br>如果指定了 rxeN 实例，则只有该实例才会受到该命令的影响。<br>crc <span class="hljs-built_in">enable</span>|<span class="hljs-built_in">disable</span><br>crc 命令将启用或禁用 RoCE ICRC 计算。 与硬件 RoCE NIC 通信需要有效的 ICRC，但当 RXE 实 例与另一个 RXE 实例通信时，禁用 CRC 时性能会更好。<br><br>此选项对于所有RXE实例都是全局的。<br></code></pre></td></tr></table></figure><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[PREFIX]/etc/rxe.conf<br>RXE 配置文件。 包含持久 RXE 实例的列表。 可以通过删除此文件来删除所有持久 RXE 实例（请注意，  这将在下一个“rxe_cfg start”时生效 - 要删除主动配置的实例，您必须“rxe_cfg stop”）。<br></code></pre></td></tr></table></figure><h2 id="配置Soft-RoCE"><a href="#配置Soft-RoCE" class="headerlink" title="配置Soft-RoCE"></a>配置Soft-RoCE</h2><p>以 <code>root</code> 用户身份，输入以下命令显示 RXE 的当前配置状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo rxe_cfg<br>  Name   Link  Driver  Speed  NMTU  IPv4_addr  RDEV  RMTU<br>  ens33  <span class="hljs-built_in">yes</span>   e1000<br></code></pre></td></tr></table></figure><p>要载入 RXE 内核模块并启动 RXE，以 <code>root</code> 用户身份输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo rxe_cfg start<br>  Name   Link  Driver  Speed  NMTU  IPv4_addr  RDEV  RMTU<br>  ens33  <span class="hljs-built_in">yes</span>   e1000                           rxe0  1024  (3)<br></code></pre></td></tr></table></figure><p>查看rdma_rxe驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ lsmod |grep rdma_rxe<br>rdma_rxe              118784  0<br>ip6_udp_tunnel         16384  1 rdma_rxe<br>udp_tunnel             16384  1 rdma_rxe<br>ib_uverbs             131072  2 rdma_rxe,rdma_ucm<br>ib_core               307200  8 rdma_cm,rdma_rxe,rpcrdma,iw_cm,ib_iser,rdma_ucm,ib_uverbs,ib_cm<br></code></pre></td></tr></table></figure><p>在通过以太网接口添加新 RXE 设备之前，应打开对应的接口并分配有有效的 IP 地址。</p><p>添加新的 RXE 设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo rxe_cfg -n add ens33<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo rxe_cfg status<br>  Name   Link  Driver  Speed  NMTU  IPv4_addr  RDEV  RMTU<br>  ens33  <span class="hljs-built_in">yes</span>   e1000                           rxe0  1024  (3)<br></code></pre></td></tr></table></figure><p>查看设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ibv_devices<br>    device             node GUID<br>    ------          ----------------<br>    rxe0            020c29fffea41f73<br></code></pre></td></tr></table></figure><p>删除 RXE 设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rxe_cfg remove ens33<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://manpages.ubuntu.com/manpages/focal/en/man8/rxe_cfg.8.html">Ubuntu Manpage: rxe_cfg - rxe configuration tool for RXE (Soft RoCE)</a></p><p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/sec-configuring_soft-_roce">13.3. 配置 Soft-RoCE Red Hat Enterprise Linux 7 | Red Hat Customer Portal</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令-ethtool</title>
    <link href="/2023/08/10/Linux%E5%91%BD%E4%BB%A4-ethtool/"/>
    <url>/2023/08/10/Linux%E5%91%BD%E4%BB%A4-ethtool/</url>
    
    <content type="html"><![CDATA[<h1 id="ethtool"><a href="#ethtool" class="headerlink" title="ethtool"></a>ethtool</h1><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">-a 查看网卡中 接收模块RX、发送模块TX和Autonegotiate模块的状态：启动on 或 停用off。<br>-A 修改网卡中 接收模块RX、发送模块TX和Autonegotiate模块的状态：启动on 或 停用off。<br>-c display the Coalesce information of the specified ethernet card 查看硬中断合并策略。<br>-C Change the Coalesce setting of the specified ethernet card 修改硬中断合并策略。<br>-g Display the rx/tx ring parameter information of the specified ethernet card 查看RingBuffer的大小。<br>-G change the rx/tx ring setting of the specified ethernet card 修改RingBuffer的大小。<br>-i 显示网卡驱动的信息，如驱动的名称、版本等。<br>-d 显示register dump信息, 部分网卡驱动不支持该选项。<br>-e 显示EEPROM dump信息，部分网卡驱动不支持该选项。<br>-E 修改网卡EEPROM byte。<br>-k 显示网卡Offload参数的状态：on 或 off，包括rx-checksumming、tx-checksumming等。<br>-K 修改网卡Offload参数的状态。<br>-p 用于区别不同ethX对应网卡的物理位置，常用的方法是使网卡port上的led不断的闪；N指示了网卡闪的持续时间，以秒为单位。<br>-r 如果auto-negotiation模块的状态为on，则restarts auto-negotiation。<br>-S 显示NIC- and driver-specific 的统计参数，如网卡接收/发送的字节数、接收/发送的广播包个数等。<br>-t 让网卡执行自我检测，有两种模式：offline or online。<br>-s 修改网卡的部分配置，包括网卡速度、单工/全双工模式、mac地址等。<br>-l 查看网卡队列数。<br>-L：修改网卡队列数。<br></code></pre></td></tr></table></figure><h2 id="查看网口基本信息"><a href="#查看网口基本信息" class="headerlink" title="查看网口基本信息"></a>查看网口基本信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ethtool ens33<br>Settings <span class="hljs-keyword">for</span> ens33:<br>Supported ports: [ TP ]<br>Supported <span class="hljs-built_in">link</span> modes:   10baseT/Half 10baseT/Full<br>                        100baseT/Half 100baseT/Full<br>                        1000baseT/Full<br>Supported pause frame use: No<br>Supports auto-negotiation: Yes<br>Supported FEC modes: Not reported<br>Advertised <span class="hljs-built_in">link</span> modes:  10baseT/Half 10baseT/Full<br>                        100baseT/Half 100baseT/Full<br>                        1000baseT/Full<br>Advertised pause frame use: No<br>Advertised auto-negotiation: Yes<br>Advertised FEC modes: Not reported<br>Speed: 1000Mb/s<br>Duplex: Full<br>Port: Twisted Pair<br>PHYAD: 0<br>Transceiver: internal<br>Auto-negotiation: on<br>MDI-X: off (auto)<br>Cannot get wake-on-lan settings: Operation not permitted<br>Current message level: 0x00000007 (7)<br>       drv probe <span class="hljs-built_in">link</span><br>Link detected: <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><h2 id="查询网口驱动相关信息-i"><a href="#查询网口驱动相关信息-i" class="headerlink" title="查询网口驱动相关信息 -i"></a>查询网口驱动相关信息 <code>-i</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ethtool -i ens33<br>driver: e1000<br>version: 5.10.0<br>firmware-version:<br>expansion-rom-version:<br>bus-info: 0000:02:01.0<br>supports-statistics: <span class="hljs-built_in">yes</span><br>supports-test: <span class="hljs-built_in">yes</span><br>supports-eeprom-access: <span class="hljs-built_in">yes</span><br>supports-register-dump: <span class="hljs-built_in">yes</span><br>supports-priv-flags: no<br></code></pre></td></tr></table></figure><h2 id="查询网口收发包统计信息-S"><a href="#查询网口收发包统计信息-S" class="headerlink" title="查询网口收发包统计信息 -S"></a>查询网口收发包统计信息 <code>-S</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ethtool -S ens33<br>NIC statistics:<br>     rx_packets: 278<br>     tx_packets: 245<br>     rx_bytes: 200034<br>     tx_bytes: 47526<br>     rx_broadcast: 0<br>     tx_broadcast: 0<br>     rx_multicast: 0<br>     tx_multicast: 0<br>     rx_errors: 0<br>     tx_errors: 0<br>     tx_dropped: 0<br>     multicast: 0<br>     collisions: 0<br>     rx_length_errors: 0<br>     rx_over_errors: 0<br>     rx_crc_errors: 0<br>     rx_frame_errors: 0<br>     rx_no_buffer_count: 0<br>     rx_missed_errors: 0<br>     tx_aborted_errors: 0<br>     tx_carrier_errors: 0<br>     tx_fifo_errors: 0<br>     tx_heartbeat_errors: 0<br>     tx_window_errors: 0<br>     tx_abort_late_coll: 0<br>     tx_deferred_ok: 0<br>     tx_single_coll_ok: 0<br>     tx_multi_coll_ok: 0<br>     tx_timeout_count: 0<br>     tx_restart_queue: 0<br>     rx_long_length_errors: 0<br>     rx_short_length_errors: 0<br>     rx_align_errors: 0<br>     tx_tcp_seg_good: 5<br>     tx_tcp_seg_failed: 0<br>     rx_flow_control_xon: 0<br>     rx_flow_control_xoff: 0<br>     tx_flow_control_xon: 0<br>     tx_flow_control_xoff: 0<br>     rx_long_byte_count: 200034<br>     rx_csum_offload_good: 266<br>     rx_csum_offload_errors: 0<br>     alloc_rx_buff_failed: 0<br>     tx_smbus: 0<br>     rx_smbus: 0<br>     dropped_smbus: 0<br></code></pre></td></tr></table></figure><p>rx_fifo_errors 如果不为 0（在 ifconfig 中体现为 overruns 指标增长），就表示有包因为 Ring Buffer 装不下而被丢弃了。增大 Ring Buffer 的大小可以缓解丢包问题。修改命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ethtool -G eth0 rx 4096 tx 4096<br></code></pre></td></tr></table></figure><p>增大队列长度可以解决偶发的瞬时丢包问题。不过会引入新的问题，那就是排队的包过多会导致网络包的延时增加。</p><h2 id="显示网卡-offload-参数的状态-k"><a href="#显示网卡-offload-参数的状态-k" class="headerlink" title="显示网卡 offload 参数的状态 -k"></a>显示网卡 offload 参数的状态 <code>-k</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ethtool -k ens33<br>Features <span class="hljs-keyword">for</span> ens33:<br>rx-checksumming: off<br>tx-checksumming: on<br>tx-checksum-ipv4: off [fixed]<br>tx-checksum-ip-generic: on<br>tx-checksum-ipv6: off [fixed]<br>tx-checksum-fcoe-crc: off [fixed]<br>tx-checksum-sctp: off [fixed]<br>scatter-gather: on<br>tx-scatter-gather: on<br>tx-scatter-gather-fraglist: off [fixed]<br>tcp-segmentation-offload: on<br>tx-tcp-segmentation: on<br>tx-tcp-ecn-segmentation: off [fixed]<br>tx-tcp-mangleid-segmentation: off<br>tx-tcp6-segmentation: off [fixed]<br>generic-segmentation-offload: on<br>generic-receive-offload: on<br>large-receive-offload: off [fixed]<br>rx-vlan-offload: on<br>tx-vlan-offload: on [fixed]<br>ntuple-filters: off [fixed]<br>receive-hashing: off [fixed]<br>highdma: off [fixed]<br>rx-vlan-filter: on [fixed]<br>vlan-challenged: off [fixed]<br>tx-lockless: off [fixed]<br>netns-local: off [fixed]<br>tx-gso-robust: off [fixed]<br>tx-fcoe-segmentation: off [fixed]<br>tx-gre-segmentation: off [fixed]<br>tx-gre-csum-segmentation: off [fixed]<br>tx-ipxip4-segmentation: off [fixed]<br>tx-ipxip6-segmentation: off [fixed]<br>tx-udp_tnl-segmentation: off [fixed]<br>tx-udp_tnl-csum-segmentation: off [fixed]<br>tx-gso-partial: off [fixed]<br>tx-tunnel-remcsum-segmentation: off [fixed]<br>tx-sctp-segmentation: off [fixed]<br>tx-esp-segmentation: off [fixed]<br>tx-udp-segmentation: off [fixed]<br>tx-gso-list: off [fixed]<br>fcoe-mtu: off [fixed]<br>tx-nocache-copy: off<br>loopback: off [fixed]<br>rx-fcs: off<br>rx-all: off<br>tx-vlan-stag-hw-insert: off [fixed]<br>rx-vlan-stag-hw-parse: off [fixed]<br>rx-vlan-stag-filter: off [fixed]<br>l2-fwd-offload: off [fixed]<br>hw-tc-offload: off [fixed]<br>esp-hw-offload: off [fixed]<br>esp-tx-csum-hw-offload: off [fixed]<br>rx-udp_tunnel-port-offload: off [fixed]<br>tls-hw-tx-offload: off [fixed]<br>tls-hw-rx-offload: off [fixed]<br>rx-gro-hw: off [fixed]<br>tls-hw-record: off [fixed]<br>rx-gro-list: off<br>macsec-hw-offload: off [fixed]<br></code></pre></td></tr></table></figure><h3 id="配置网卡-offload-参数-K"><a href="#配置网卡-offload-参数-K" class="headerlink" title="配置网卡 offload 参数 -K"></a>配置网卡 offload 参数 <code>-K</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ethtool -K eth0 rx-checksum on|off<br>$ ethtool -K eth0 tx-checksum-ip-generic on|off<br>$ ethtool -K eth0 tso on|off<br>$ ethtool -K eth0 ufo on | off<br>$ ethtool -K eth0 gso on | off<br>$ ethtool -K eth0 ntuple on | off<br></code></pre></td></tr></table></figure><h2 id="查看多队列网卡的队列使用情况-l"><a href="#查看多队列网卡的队列使用情况-l" class="headerlink" title="查看多队列网卡的队列使用情况 -l"></a>查看多队列网卡的队列使用情况 <code>-l</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ethtool -l eth0<br></code></pre></td></tr></table></figure><h3 id="修改队列数-L"><a href="#修改队列数-L" class="headerlink" title="修改队列数 -L"></a>修改队列数 <code>-L</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ethtool -L eth0 combined 32<br></code></pre></td></tr></table></figure><h3 id="查看网卡队列绑定信息"><a href="#查看网卡队列绑定信息" class="headerlink" title="查看网卡队列绑定信息"></a>查看网卡队列绑定信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注意修改网卡名称eth0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `<span class="hljs-built_in">cat</span> /proc/interrupts | grep eth0 \<br> | awk -F: <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>`; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span> &amp;&amp; <span class="hljs-built_in">cat</span> /proc/irq/<span class="hljs-variable">$i</span>/smp_affinity ; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="在文件系统查看生效的网卡队列数量"><a href="#在文件系统查看生效的网卡队列数量" class="headerlink" title="在文件系统查看生效的网卡队列数量"></a>在文件系统查看生效的网卡队列数量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> /sys/class/net/eth0/queues<br></code></pre></td></tr></table></figure><h2 id="硬中断合并"><a href="#硬中断合并" class="headerlink" title="硬中断合并"></a>硬中断合并</h2><p>发生硬中断时，CPU 会消耗一部分性能来处理上下文切换，以便处理完中断后恢复原来的工作，如果网卡每收到一个包就触发硬中断，频繁中断会使 CPU 工作效率变低。如果能适当降低中断的频率，多攒几个包一起发出硬中断，会使 CPU 的工作效率提升。虽然降低中断频率能使得收包并发量提高，但是会使一些包的延迟增大。</p><h3 id="查看硬中断合并策略-c"><a href="#查看硬中断合并策略-c" class="headerlink" title="查看硬中断合并策略 -c"></a>查看硬中断合并策略 <code>-c</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">ethtool -c ens33<br>Coalesce parameters <span class="hljs-keyword">for</span> ens33:<br>Adaptive RX: off  TX: off<br>stats-block-usecs: 0<br>sample-interval: 0<br>pkt-rate-low: 0<br>pkt-rate-high: 0<br><br>rx-usecs: 3<br>rx-frames: 0<br>rx-usecs-irq: 0<br>rx-frames-irq: 0<br><br>tx-usecs: 0<br>tx-frames: 0<br>tx-usecs-irq: 0<br>tx-frames-irq: 0<br><br>rx-usecs-low: 0<br>rx-frames-low: 0<br>tx-usecs-low: 0<br>tx-frames-low: 0<br><br>rx-usecs-high: 0<br>rx-frames-high: 0<br>tx-usecs-high: 0<br>tx-frames-high: 0<br></code></pre></td></tr></table></figure><ul><li><strong>Adaptive RX</strong>：自适应中断合并，网卡驱动自己判断啥时候合并；</li><li><strong>rx-usecs</strong>：每当过这么长时间过后，触发一个 RX interrupt 硬中断；</li><li><strong>rx-frames</strong>：每当累计收到这么多个帧后，触发一个 RX interrupt 硬中断；</li></ul><h3 id="修改硬中断合并策略-C"><a href="#修改硬中断合并策略-C" class="headerlink" title="修改硬中断合并策略 -C"></a>修改硬中断合并策略 <code>-C</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ethtool -C eth0 adaptive-rx on<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/yunlianglinfeng/article/details/120458288">Linux系统下查看网卡相关数据_ethtool bus-info_香烟头的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令-arp</title>
    <link href="/2023/08/10/Linux%E5%91%BD%E4%BB%A4-arp/"/>
    <url>/2023/08/10/Linux%E5%91%BD%E4%BB%A4-arp/</url>
    
    <content type="html"><![CDATA[<h1 id="arp"><a href="#arp" class="headerlink" title="arp"></a>arp</h1><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示 arp 缓冲区的所有条目；</td></tr><tr><td>-d</td><td>从 arp 缓冲区中删除指定主机的 arp 条目；</td></tr><tr><td>-D</td><td>使用指定接口的硬件地址；</td></tr><tr><td>-e</td><td>以 Linux 的显示风格显示 arp 缓冲区中的条目；</td></tr><tr><td>-f</td><td>设置主机的 IP 地址与 MAC 地址的静态映射;</td></tr><tr><td>-g</td><td>显示ARP缓存列表;</td></tr><tr><td>-H</td><td>指定 arp 指令使用的地址类型；</td></tr><tr><td>-i</td><td>指定要操作 arp 缓冲区的网络接口；</td></tr><tr><td>-n</td><td>以数字方式显示 arp 缓冲区中的条目；</td></tr><tr><td>-v</td><td>显示详细的 arp 缓冲区条目，包括缓冲区条目的统计信息；</td></tr><tr><td>-s</td><td>设置指定的主机的 IP 地址与 MAC 地址的静态映射；</td></tr><tr><td>–version</td><td>显示版本信息.</td></tr></tbody></table><h2 id="显示本机arp缓存中所有记录"><a href="#显示本机arp缓存中所有记录" class="headerlink" title="显示本机arp缓存中所有记录"></a>显示本机arp缓存中所有记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@linuxcool ~]<span class="hljs-comment"># arp</span><br>Address                  HWtype  HWaddress           Flags Mask            Iface<br>_gateway                 ether   00:50:56:ff:bf:31   C                     ens33<br></code></pre></td></tr></table></figure><h2 id="以数字方式显示指定主机arp缓存条目"><a href="#以数字方式显示指定主机arp缓存条目" class="headerlink" title="以数字方式显示指定主机arp缓存条目"></a>以数字方式显示指定主机arp缓存条目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@linuxcool ~]<span class="hljs-comment"># arp -n 192.168.198.2</span><br>Address                  HWtype  HWaddress           Flags Mask            Iface<br>192.168.198.2            ether   00:50:56:ff:bf:31   C                     ens33<br></code></pre></td></tr></table></figure><h2 id="删除指定主机网卡上的arp条目"><a href="#删除指定主机网卡上的arp条目" class="headerlink" title="删除指定主机网卡上的arp条目"></a>删除指定主机网卡上的arp条目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@linuxcool ~]<span class="hljs-comment"># arp -i ens33 -d 192.168.198.2</span><br></code></pre></td></tr></table></figure><h2 id="添加对指定的IP地址和MAC地址进行静态映射条目"><a href="#添加对指定的IP地址和MAC地址进行静态映射条目" class="headerlink" title="添加对指定的IP地址和MAC地址进行静态映射条目"></a>添加对指定的IP地址和MAC地址进行静态映射条目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@linuxcool ~]<span class="hljs-comment"># arp -s 192.168.198.2 00:50:56:ff:bf:31</span><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.linuxcool.com/arp">arp命令 – 管理系统arp缓存信息 – Linux命令大全(手册) (linuxcool.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令-进程后台执行</title>
    <link href="/2023/08/10/Linux%E5%91%BD%E4%BB%A4-%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C/"/>
    <url>/2023/08/10/Linux%E5%91%BD%E4%BB%A4-%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="进程后台运行"><a href="#进程后台运行" class="headerlink" title="进程后台运行"></a>进程后台运行</h1><p>要在后台运行 Linux 命令，只需要在命令的末尾添加一个 &amp; 符号，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">iperf -s<br>iperf -c 127.0.0.1 -t 10 &gt; log.txt &amp;<br></code></pre></td></tr></table></figure><p>当命令在后台完成时，你应该能在终端上看到该命令的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[1]  + 5728 <span class="hljs-keyword">done</span>       iperf -c 127.0.0.1 -t 10 &gt; log.txt<br></code></pre></td></tr></table></figure><h2 id="将正在运行的进程发送到后台"><a href="#将正在运行的进程发送到后台" class="headerlink" title="将正在运行的进程发送到后台"></a>将正在运行的进程发送到后台</h2><p>按 Ctrl + Z 键暂停当前进程，然后使用 bg（background 的缩写）向后台发送进程，该被挂起的进程就会转到后台继续运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sleep</span> 30<br>^z<br><span class="hljs-built_in">bg</span><br></code></pre></td></tr></table></figure><h2 id="查看后台运行的所有进程"><a href="#查看后台运行的所有进程" class="headerlink" title="查看后台运行的所有进程"></a>查看后台运行的所有进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">jobs</span><br></code></pre></td></tr></table></figure><h2 id="将后台运行的进程转至前台"><a href="#将后台运行的进程转至前台" class="headerlink" title="将后台运行的进程转至前台"></a>将后台运行的进程转至前台</h2><p>要恢复后台进程，可使用 fg（foreground的简写） 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">fg</span><br></code></pre></td></tr></table></figure><p>单单使用 fg 命令而不带任何参数，会把后台作业列表中的最后一个进程带到前台。</p><p>如果我们要将某个指定的进程带到前台，还需要指定作业的 id。这个 id 就是我们前面提到的，使用 jobs 命令的输出中，每一行最前面的数字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">fg</span> n<br></code></pre></td></tr></table></figure><p>后台运行某个命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> iperf -c 127.0.0.1 -t 10 -l 256 &gt;&gt; iperf_Test.<span class="hljs-built_in">log</span> | iperf -c 127.0.0.1 -t 10 -l 256 &gt;&gt; iperf_test.log &amp;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux拥塞控制算法配置</title>
    <link href="/2023/08/04/Linux%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/08/04/Linux%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux拥塞控制算法配置"><a href="#Linux拥塞控制算法配置" class="headerlink" title="Linux拥塞控制算法配置"></a>Linux拥塞控制算法配置</h1><p>在Linux用户态可以<strong>通过参数查看当前使用的拥塞控制算法、当前可支持的拥塞控制算法</strong>。如下表所示是两个参数以及含义。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>net.ipv4.tcp_congestion_control</td><td>当前运行的拥塞控制算法</td></tr><tr><td>net.ipv4.tcp_available_congestion_control</td><td>当前可支持的拥塞控制算法</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看当前运行的拥塞控制算法</span><br>$ sysctl net.ipv4.tcp_congestion_control<br><span class="hljs-comment">#查看当前可支持的拥塞控制算法</span><br>$ sysctl net.ipv4.tcp_available_congestion_control<br></code></pre></td></tr></table></figure><h2 id="查看Linux系统中所有已实现的拥塞控制算法模块："><a href="#查看Linux系统中所有已实现的拥塞控制算法模块：" class="headerlink" title="查看Linux系统中所有已实现的拥塞控制算法模块："></a>查看Linux系统中所有已实现的拥塞控制算法模块：</h2><p><img src="/image/Linux%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E9%85%8D%E7%BD%AE/image-20230803094446632.png#pic_center" alt="image-20230803094446632"></p><h2 id="安装特定拥塞控制算法"><a href="#安装特定拥塞控制算法" class="headerlink" title="安装特定拥塞控制算法"></a>安装特定拥塞控制算法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ modprobe -a tcp_vegas<br></code></pre></td></tr></table></figure><h2 id="动态切换拥塞控制算法"><a href="#动态切换拥塞控制算法" class="headerlink" title="动态切换拥塞控制算法"></a>动态切换拥塞控制算法</h2><p>当前使用的拥塞控制算法外<strong>还可以动态切换拥塞控制算法。如下所示将默认的cubic拥塞控制算法切换为bbr拥塞控制算法。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.core.default_qdisc=fq&quot;</span> &gt;&gt; /etc/sysctl.conf<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.ipv4.tcp_congestion_control=bbr&quot;</span> &gt;&gt; /etc/sysctl.conf<br>$ sysctl -p<br>kernel.shmmax = 9223372036854775807<br>kernel.shmall = 1152921504606846720<br>net.core.default_qdisc = fq<br>net.ipv4.tcp_congestion_control = bbr<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s/J_EE4oDxP7MmD7qlp9hL1w">Linux内核网络-拥塞控制系列(一） (qq.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>拥塞控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RDMA学习资源快速检索目录</title>
    <link href="/2023/07/17/RDMA%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%BF%AB%E9%80%9F%E6%A3%80%E7%B4%A2%E7%9B%AE%E5%BD%95/"/>
    <url>/2023/07/17/RDMA%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%BF%AB%E9%80%9F%E6%A3%80%E7%B4%A2%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Infiniband1-3中文手册-IB-Specification-Vol-1-Release-1-3-2015-03-03"><a href="#Infiniband1-3中文手册-IB-Specification-Vol-1-Release-1-3-2015-03-03" class="headerlink" title="[Infiniband1.3中文手册]IB Specification Vol 1-Release-1.3-2015-03-03"></a>[Infiniband1.3中文手册]IB Specification Vol 1-Release-1.3-2015-03-03</h1><blockquote><p>作者：NGDCN<br>网址：<a href="http://ngdcn.com/">http://ngdcn.com</a></p></blockquote><p><a href="https://ngdcn.com/post/94.html">【Infiniband手册】第3章：架构预览 - NGDCN</a></p><p><a href="https://ngdcn.com/post/96.html">【Infiniband手册】第4章：寻址&#x2F;Addressing - NGDCN</a></p><p><a href="https://ngdcn.com/post/97.html">【Infiniband手册】第5章：数据报文格式 - NGDCN</a></p><p><a href="https://ngdcn.com/post/97.html">【Infiniband手册】第5章：数据报文格式 - NGDCN</a></p><p><a href="https://ngdcn.com/post/104.html">【Infiniband手册】第6章：物理层接口 - NGDCN</a></p><p><a href="https://ngdcn.com/post/105.html">【Infiniband手册】第7章：链路层 - NGDCN</a></p><p><a href="https://ngdcn.com/post/106.html">【Infiniband手册】第8章：网络层 - NGDCN</a></p><p><a href="https://ngdcn.com/post/107.html">【Infiniband手册】第9章：传输层 - NGDCN</a></p><p><a href="https://ngdcn.com/post/148.html">【Infiniband手册】第10章：软件传输接口 - NGDCN</a></p><h1 id="知乎大神Savir的RDMA系列"><a href="#知乎大神Savir的RDMA系列" class="headerlink" title="知乎大神Savir的RDMA系列"></a>知乎大神<a href="https://www.zhihu.com/people/saviour-li">Savir</a>的RDMA系列</h1><blockquote><p>作者：Savir</p><p>网址：<a href="https://www.zhihu.com/people/saviour-li">Savir - 知乎 (zhihu.com)</a></p><p>专栏：<a href="https://www.zhihu.com/column/c_1231181516811390976">RDMA杂谈 - 知乎 (zhihu.com)</a></p></blockquote><h2 id="专栏"><a href="#专栏" class="headerlink" title="专栏"></a>专栏</h2><p><a href="https://zhuanlan.zhihu.com/p/164908617">0. 《RDMA杂谈》专栏索引 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/138874738">1. RDMA概述 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/139548242">2. 比较基于传统以太网与RDMA技术的通信 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/141267386">3. RDMA基本元素 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/142175657">4. RDMA操作类型 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/144099636">5. RDMA基本服务类型 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/156975042">6. RDMA之Memory Region - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/159493100">7. RDMA之Protection Domain - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/163552044">8. RDMA之Address Handle - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/195757767">9. RDMA之Queue Pair - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/259650980">10. RDMA之Completion Queue - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/279904125">11. RDMA之Shared Receive Queue - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/329198771">12. RDMA之Verbs - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/346708569">13. RDMA之用户态与内核态交互 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/353590347">14. RDMA之Memory Window - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/361740115">15. RDMA之RoCE &amp; Soft-RoCE - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/408817872">16. RDMA之DDP(Direct Data Placement) - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/421211722">17. RDMA之RDMAP(Remote Direct Memory Access Protocol) - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/435467605">18. RDMA之MPA(Marker PDU Aligned framing) - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/455174484">20. RDMA之Pyverbs(Python Verbs) - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/463199854">21. RDMA之内存地址基础知识 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/476407641">22. RDMA之基于Socket API的QP间建链 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/494826608">23. RDMA之基于CM API的QP间建链 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/565736840">24. RDMA之Queue Buffer - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/642286038">25. RDMA之用户态MR Buffer - 知乎 (zhihu.com)</a></p><h1 id="CSDN大神bandaoyu的RDMA专栏"><a href="#CSDN大神bandaoyu的RDMA专栏" class="headerlink" title="CSDN大神bandaoyu的RDMA专栏"></a>CSDN大神<a href="https://blog.csdn.net/bandaoyu?type=blog">bandaoyu</a>的<a href="https://blog.csdn.net/bandaoyu/category_11340014.html">RDMA</a>专栏</h1><p><a href="https://blog.csdn.net/bandaoyu/article/details/120485737">【RDMA】RDMA 学习资料总目录_rdma开发 书_bandaoyu的博客-CSDN博客</a></p><h2 id="RDMA专栏"><a href="#RDMA专栏" class="headerlink" title="RDMA专栏"></a>RDMA专栏</h2><p>专栏 <a href="https://blog.csdn.net/bandaoyu/category_11340014.html">RDMA_bandaoyu的博客-CSDN博客</a></p><p><strong>RDMA技术详解</strong></p><p><a href="https://blog.csdn.net/bandaoyu/article/details/112859853">【RDMA】技术详解（一）：RDMA概述_bandaoyu的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/bandaoyu/article/details/112859932">【RDMA】技术详解（二）：Send Receive操作_ibv_send_recv_bandaoyu的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/bandaoyu/article/details/112859981">【RDMA】技术详解（三）：理解RDMA Scatter Gather List|聚散表_bandaoyu的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/bandaoyu/article/details/112860396">【RDMA】技术详解（四）：RDMA之Verbs和编程步骤_ibv_qp_init_attr_bandaoyu的博客-CSDN博客</a></p><h2 id="网络专栏"><a href="#网络专栏" class="headerlink" title="网络专栏"></a>网络专栏</h2><p>专栏 <a href="https://blog.csdn.net/bandaoyu/category_8400071.html">网络编程_bandaoyu的博客-CSDN博客</a></p><h1 id="论坛"><a href="#论坛" class="headerlink" title="论坛"></a>论坛</h1><p><a href="https://ngdcn.com/">NGDCN - 未来网络技术网</a></p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p><a href="http://www.rdmamojo.com/">RDMAmojo - RDMAmojo - blog on RDMA technology and programming by Dotan Barak RDMAmojo</a></p><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><p><a href="https://www.youtube.com/watch?v=NumH5YeVjHU">(23) The Linux SoftRoCE Driver - YouTube</a> OFA组织2017年年会时对于Soft-RoCE实现的介绍视频</p><h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><p><a href="https://book.douban.com/subject/36322557/">《Linux高性能网络详解：从DPDK、RDMA到XDP》</a></p><h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><p>RDMA编程入门可参考的项目：</p><p><a href="https://github.com/tarickb/the-geek-in-the-corner">https://github.com/tarickb/the-geek-in-the-corner</a></p><p><a href="https://github.com/jcxue/RDMA-Tutorial">https://github.com/jcxue/RDMA-Tutorial</a></p>]]></content>
    
    
    <categories>
      
      <category>RDMA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RDMA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IBA功能</title>
    <link href="/2023/07/15/IBA%E5%8A%9F%E8%83%BD/"/>
    <url>/2023/07/15/IBA%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="IBA功能-Features"><a href="#IBA功能-Features" class="headerlink" title="IBA功能(Features)"></a>IBA功能(Features)</h1><h2 id="队列对（Queue-Pairs）"><a href="#队列对（Queue-Pairs）" class="headerlink" title="队列对（Queue Pairs）"></a>队列对（Queue Pairs）</h2><p>QP是硬件提供给IBA消费者的虚拟接口；它为消费者提供虚拟通信端口。该体系结构支持每个通道适配器（channel adapter）最多2<sup>24</sup>个QP；每个QP的操作与其他QP无关。每个QP提供高度的隔离和保护，以防止其他QP操作和其他消费者。因此，可以将QP视为分配给单个消费者的私有资源。如图17所示，消费者可能会使用多个QP。</p><p><img src="/image/IBA%E5%8A%9F%E8%83%BD/image-20230714151031129.png#pic_center" alt="image-20230714151031129"></p><p>消费者通过分配QP并指定其服务类别来创建此虚拟通信端口。通信在源QP和目标QP之间进行。对于连接定向服务，每个QP都与一个其他QP紧密绑定，通常位于不同的节点上。消费者启动任何必要的通信建立以将QP与目标QP绑定，并使用某些信息（例如目标LID，服务级别和协商的操作限制）配置QP上下文。</p><p>消费者向QP发布工作请求以通过该QP调用通信。</p><h2 id="服务类型（Types-of-Service）"><a href="#服务类型（Types-of-Service）" class="headerlink" title="服务类型（Types of Service）"></a>服务类型（Types of Service）</h2><p>根据源QP和接收QP的交互方式，为每个QP配置一定的操作类别（称为服务类型）。源QP和目标QP都必须配置为相同的服务类型。每种服务类型都基于以下属性。</p><p>已收到消息. 根据源QP和接收QP的交互方式，为每个QP配置一定的操作类别（称为服务类型）。源QP和目标QP都必须配置为相同的服务类型。每种服务类型都基于以下属性。</p><ul><li><strong>面向连接与数据报</strong> - 对于面向连接的服务，QP与一个其他QP关联，并且所有发布到QP的工作请求都会导致发送到已建立的目标QP的消息。数据报操作允许使用单个QP向任何节点上的任何适当QP发送和接收消息。</li><li><strong>可靠与不可靠</strong> - IBA传输通过一系列确认来保证可靠性。对于可靠服务，传输保证在没有错误的情况下按顺序且仅一次地传递每个消息。为了提供这种可靠性，接收QP使用肯定确认（ACK）或否定确认（NAK）确认所有接收到的入站请求。对于不可靠的服务，传输协议不能保证传递所有数据，尽管有机制可以确保所有接收到的数据最多传递一次，并且传递的数据未损坏。此外，某些情况下，布线配置的更改可能导致数据无序传递；可靠服务可以检测并从这些情况中恢复。不可靠的服务可以检测到这些情况，但无法独立从中恢复。</li><li><strong>IBA传输与其他传输</strong> - IBA传输服务为基于通道和基于内存的操作定义了特定的传输协议。IBA还支持使用通道适配器作为数据链路引擎在节点之间发送原始数据包，这对于支持遗留协议堆栈和遗留网络非常有用。</li></ul><center>IBA定义的服务类型</center><table><thead><tr><th align="left">服务类型</th><th align="center">面向连接</th><th align="center">Acknowledged</th><th align="center">Transport</th></tr></thead><tbody><tr><td align="left">可靠连接（Reliable Connection）</td><td align="center">√</td><td align="center">√</td><td align="center">IBA</td></tr><tr><td align="left">不可靠连接（Unreliable Connection ）</td><td align="center">√</td><td align="center">×</td><td align="center">IBA</td></tr><tr><td align="left">可靠数据报（Reliable Datagram ）</td><td align="center">×</td><td align="center">√</td><td align="center">IBA</td></tr><tr><td align="left">不可靠数据报（Unreliable Datagram）</td><td align="center">×</td><td align="center">×</td><td align="center">IBA</td></tr><tr><td align="left">原始数据报（RAW Datagram ）</td><td align="center">×</td><td align="center">×</td><td align="center">IBA</td></tr></tbody></table><p>某些IBA操作仅适用于某些服务类别。如果操作不适用于配置的服务类别，则QP会拒绝WQE。</p><p>面向连接的服务要求消费者启动与目标节点的通信建立过程（连接设置）以关联QP并在任何QP操作之前建立QP上下文。实际上，除了原始数据报之外的所有服务类别都需要某种形式的通信设置来关联队列对。对于可靠数据报服务，节点执行通信建立过程以将端到端（EE）上下文（稍后将进行解释）与每个目标节点关联。为可靠数据报服务配置的所有QP都使用已建立的EE上下文，并且工作请求指定要用于该操作的EE上下文。</p><p>原始数据报与不可靠数据报类似，只是源QP不知道将接收和处理消息的QP的身份。原始数据报允许路由器将原始数据报分组转发到没有等效QP的不同结构（如LAN或WAN）上的非IBA目的地。有两种类型的原始数据报，IPv6和Ethertype。IPv6原始数据报包含全局路由报头，并且分组有效载荷包含在全局路由报头中标识的传输协议服务数据单元。以太网类型原始数据报包含以太网类型字段，数据包有效载荷包含以太网类型字段中标识的传输协议服务数据单元。</p><p>IBA定义了通道（发送&#x2F;接收）和内存（RDMA）语义。原始数据报和不可靠数据报服务不支持内存语义。</p><h2 id="密钥（Keys）"><a href="#密钥（Keys）" class="headerlink" title="密钥（Keys）"></a><span id="keys">密钥（Keys）</span></h2><p>IBA使用各种密钥提供隔离和保护。密钥是由管理实体分配的值，以各种方式在消息中使用。密钥本身不提供安全性，因为密钥在跨越结构的消息中是可用的，因此任何能够到达结构内部的实体都可以确定密钥值。 IBA确实对应用程序如何访问某些密钥施加了限制。</p><ul><li><p><strong>管理密钥</strong>（M_Key）：强制执行主子网管理器的控制。由子网管理器管理，并用于某些子网管理数据包。每个通道适配器端口都有一个由SM设置并启用的M_Key。SM可以为每个端口分配不同的密钥。启用后，端口拒绝某些不包含编程M_Key的管理数据包。因此，只有具有编程M_Key的SM才能更改节点的布线配置。只要SM处于活动状态，SM可以防止读取端口的M_Key。端口维护超时时间，因此如果SM失败，则端口将恢复到未受管理状态。交换机只有一个M_Key。</p></li><li><p><strong>基板管理密钥</strong>（B_Key）：强制控制子网基板管理器。由子网基板管理器管理并在某些MAD中使用。每个通道适配器端口都有一个由基板管理器设置的B_Key。基板管理器可以为每个端口分配不同的密钥。启用后，端口拒绝不包含编程B_Key的某些管理数据包。因此，只有具有编程B_Key的基板管理器才能更改节点的基板配置。只要基板管理器处于活动状态，基板管理器就可以防止读取端口的B_Key。端口维护超时时间，因此如果基板管理器失败，则端口将恢复到未受管状态。交换机有一个B_Key。</p></li><li><p><strong>分区密钥</strong>（P_Key）：强制成员身份。分区管理器（PM）通过子网管理器进行管理。每个通道适配器端口都包含一个由PM设置的分区密钥表。需要为相同的分区配置QP才能进行通信（除了QP0，QP1和配置为原始数据报的端口），因此P_Key在每个IB传输数据包中都会携带。通信建立过程的一部分确定特定QP或EEC使用的P_Key。EEC包含可靠数据报服务的P_Key，而QP上下文包含其他IBA传输类型的P_Key。在发送的每个数据包中，将QP或EEC中的P_Key放置，并将其与接收到的每个数据包中的P_Key进行比较。比较P_Key失败的接收数据包将被拒绝。每个交换机都有一个用于管理消息的P_Key表，并且可以选择支持基于其P_Key过滤数据包的分区强制表。</p></li><li><p><strong>队列密钥</strong>（Q_Key）：强制可靠和不可靠数据报服务的访问权限（不包括RAW数据报服务类型）。由通道适配器管理。在数据报服务的通信建立期间，节点为特定队列对交换Q_Key，节点在发送到远程QP的所有数据包中使用传递给其远程QP的值。同样，远程节点使用提供的Q_Key。接收到具有不同于节点提供给远程队列对的Q_Key的数据包意味着该数据包无效，因此被拒绝。</p><p>具有最高有效位集的Q_Key被认为是受控Q_Keys（例如GSI Q_Key），并且HCA不允许消费者任意指定受控Q_Key。尝试发送受控Q_Key会导致使用QP上下文中的Q_Key。因此，操作系统保持控制权，因为它可以为特权消费者配置受控Q_Key的QP上下文。</p></li><li><p><strong>内存密钥</strong>（L_Key和R_Key）：启用虚拟地址并为消费者提供控制访问其内存的机制。这些密钥由通道适配器通过注册过程进行管理。消费者向通道适配器注册一个内存区域，并接收L_Key和R_Key。消费者在工作请求中使用L_Key来描述本地内存，并将R_Key传递给远程消费者以用于RDMA操作。当消费者排队RDMA操作时，它指定了从远程消费者传递给它的R_Key，并且R_Key包含在RDMA请求数据包中，发送到原始通道适配器。 R_Key验证发送方访问目标内存的权利，并为目标通道适配器提供将虚拟地址转换为物理地址的手段。</p></li></ul><h2 id="虚拟内存地址（Virtual-Memory-Address）"><a href="#虚拟内存地址（Virtual-Memory-Address）" class="headerlink" title="虚拟内存地址（Virtual Memory Address）"></a>虚拟内存地址（Virtual Memory Address）</h2><p>IBA针对虚拟寻址进行了优化。也就是说，IBA消费者在工作请求中使用虚拟地址，通道适配器能够根据需要将虚拟地址转换为物理地址。为了实现这一点，每个消费者都向通道适配器注册虚拟内存区域，并且通道适配器返回2个内存句柄，称为L_Key和R_Key。然后，消费者在需要访问该区域的每个工作请求中使用L_Key。有关L_Key使用的说明，请参见<a href="#keys">密钥</a>。<br>内存注册提供了机制，允许IBA消费者描述一组虚拟连续的内存位置或一组物理连续的内存位置，以便HCA使用虚拟地址将内存作为虚拟连续缓冲区访问。</p><p>IBA还支持远程内存访问（RDMA），允许远程消费者访问已注册的内存。对于RDMA，消费者将R_KEY和该内存区域中缓冲区的虚拟地址传递给另一个消费者。该远程消费者在其RDMA WQE中提供该R_Key，以访问原始节点中的内存。有关R_Key使用的详细说明，请参见<a href="#keys">密钥</a>。</p><h2 id="保护域（Protection-Domains）"><a href="#保护域（Protection-Domains）" class="headerlink" title="保护域（Protection Domains）"></a>保护域（Protection Domains）</h2><p>内存注册不仅允许使用虚拟内存寻址，而且还提供了更高级别的保护，以防止意外和未经授权的访问。</p><p>由于消费者可能与许多不同的目标通信，但不希望让所有这些目标都对其注册的内存具有相同的访问权限，因此IBA提供了保护域。保护域允许使用者控制哪一组内存区域和哪一组QP可以访问内存窗口。</p><p>在消费者分配QP或注册内存之前，它会创建一个或多个保护域。 QP分配给保护域，并向保护域注册内存。特定内存域的L_Key和R_Key仅在为同一保护域创建的QP上有效。</p><h2 id="分区（Partitions）"><a href="#分区（Partitions）" class="headerlink" title="分区（Partitions）"></a>分区（Partitions）</h2><p>分区强制在共享InfiniBand结构的系统之间实现隔离。分区与子网，交换机或路由器建立的边界无关。相反，分区描述了结构中可以通信的一组终节点。</p><p>端节点的每个端口都是至少一个分区的成员，并且可能是多个分区的成员。分区管理器为每个通道适配器端口分配分区键（P_Keys）。每个P_Key表示一个分区。每个QP<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="除了为原始数据报服务类型配置的QP0、QP1和QPs。">[1]</span></a></sup>和EE上下文都分配给一个分区，并在其发送的所有数据包中使用该P_Key，并检查其接收到的所有数据包中的P_Key。接收到无效的P_Key会导致数据包被丢弃。</p><p>交换机和路由器可以选择用于强制分区。在这种情况下，分区管理器使用P_Key信息对交换机或路由器进行编程，当交换机或路由器检测到具有无效P_Key的数据包时，它会丢弃该数据包。</p><h2 id="虚拟通道（Virtual-Lanes）"><a href="#虚拟通道（Virtual-Lanes）" class="headerlink" title="虚拟通道（Virtual Lanes）"></a>虚拟通道（Virtual Lanes）</h2><p>虚拟通道（VL）提供了一种用于在单个物理链路内创建多个虚拟链路的机制。虚拟通道表示端口中的一组传输和接收缓冲区。所有端口都支持VL<sub>15</sub>，该VL专门用于子网管理。还有15个其他VL（VL<sub>0</sub>到VL<sub>14</sub>）称为数据VL，所有端口都支持至少一个数据VL（VL<sub>0</sub>），并且可以提供VL<sub>1</sub>到VL<sub>n-1</sub>，其中n是端口支持的数据VL的数量）。端口使用的实际数据VL由SM配置，并基于数据包中的服务级别（SL）字段。默认情况下，使用VL0，直到SM确定链接两端支持的VL数量并将端口的SL编程为VL映射表。</p><p>该端口对每个数据VL保持单独的流量控制，使得一个VL上的过多流量不会阻塞另一个VLAN上的流量。</p><p><img src="/image/IBA%E5%8A%9F%E8%83%BD/image-20230714163556094.png#pic_center" alt="image-20230714163556094"></p><p>VL分配仅存在于链路两端的端口之间，并且一个链路上的VL分配独立于其他链路上的分配与其他链接上的分配无关。</p><p>每个数据包都有一个SL，该SL在数据包报头中指定。当数据包遍历结构时，其SL确定在每个链路上将使用哪个VL。</p><p>每个端口维护一个SL到VL映射表，以便在适当的VL上发送数据包。</p><p>当链路两端的端口支持不同数量的数据VL时，数量较高的端口会降级为另一个端口支持的数量。因此，对于仅支持单个数据VL的端口，所有数据流量默认为VL<sub>0</sub>。</p><h2 id="服务质量（Quality-of-Service）"><a href="#服务质量（Quality-of-Service）" class="headerlink" title="服务质量（Quality of Service）"></a>服务质量（Quality of Service）</h2><p>IBA提供了几种机制，允许子网管理器管理连接和无连接服务的各种服务质量保证。这些机制是服务级别，服务级别到虚拟通道映射和分区。 IBA不定义服务质量（QoS）级别（例如，尽力而为）。</p><h3 id="服务级别（Server-Level）"><a href="#服务级别（Server-Level）" class="headerlink" title="服务级别（Server Level）"></a>服务级别（Server Level）</h3><p>IBA定义了一个服务级别（SL）属性，允许数据包在16个服务级别中的一个级别上运行。每个服务级别的定义和目的都超出了架构的范围，并作为结构管理策略留给了管理员。因此，服务级别的分配是每个节点的通信管理器及其与子网管理器协商的功能。</p><h3 id="SL到VL映射"><a href="#SL到VL映射" class="headerlink" title="SL到VL映射"></a>SL到VL映射</h3><p>与服务级别相关的另一个IBA机制是虚拟通道。每个数据包都标识其SL，当数据包遍历结构时，数据包的SL是确定下一个链接上使用哪个VL的组成部分。为此，每个端口（交换机，路由器，终节点）都有一个由子网管理配置的SL到VL<sub>s</sub>映射表。当然，对于终止于仅支持一个数据VL的端口的所有链路，所有SL都映射到VL<sub>0</sub>。</p><p>否则，子网管理策略确定将每个SL映射到可用VL。</p><p>寻址QP0的数据包是子网管理数据包（SMP），并且仅使用VL15，并且忽略其SL。 VL<sub>15</sub>（管理VL）不是数据VL，并且不用于未寻址QP<sub>0</sub>的数据包。</p><h3 id="分区（Partitions）-1"><a href="#分区（Partitions）-1" class="headerlink" title="分区（Partitions）"></a>分区（Partitions）</h3><p>与服务级别相关的另一个IBA机制是分区。结构管理可以为特定分区分配某些SL<sub>s</sub>。这允许SM隔离这些分区之间的业务流，即使两个分区都以相同的QoS级别运行，也可以保证每个分区公平地共享带宽，而不管其他分区中的节点是否行为不当或订阅过多。</p><h2 id="注入速率控制（Injection-Rate-Control）"><a href="#注入速率控制（Injection-Rate-Control）" class="headerlink" title="注入速率控制（Injection Rate Control）"></a>注入速率控制（Injection Rate Control）</h2><p>IBA定义了许多不同的链路速率。最低的2.5 Gb&#x2F;sec比特率称为1x（一倍）链路。其他链路速率为10Gb&#x2F;sec（4x）和30 Gb&#x2F;sec（x12）。请参见InfiniBand Trade Association网站（<a href="www.infinibandta.org">www.infinibandta.org</a>）以了解当前速度路线图规划。为了在结构内支持多个链路速度，IBA定义了一种静态速率控制机制，该机制可防止具有高速链接的端口超出具有较低速度链接的端口的容量。</p><p>作为路径解析过程的一部分，SubnAdm:PathRecord为节点提供路径的MTU和速率信息。路径信息用于确定限制因素是交换机端口还是端节点。</p><p>图19中的示例说明，具有12x链路速度的端口A具有以3倍端口B的容量和12倍端口C、D或E的容量注入流量的潜力。此外，端口B有可能以端口C、D或E的4倍容量注入流量。由于流量往往是突发性的，因此每次端口A发送到其他端口时，结构都有很高的拥塞概率。链路流控制使结构不会因为拥塞而丢失数据包，但是反向压力会影响其他本来不会拥塞的路径。</p><p>IBA通过为以大于1x的链路速度运行的端口定义静态速率控制机制来解决此问题。</p><p><img src="/image/IBA%E5%8A%9F%E8%83%BD/image-20230715091421672.png#pic_center" alt="image-20230715091421672"></p><p>每个目的地都有一个与其相关的超时值，该超时值基于源和目的地比特率之间的比率。当源和目标比特率相等时，超时值为0（不需要）。否则，当端口将数据包发送到目的地时，它会将该目的地LID和超时值放入其静态速率控制表中。超时期限到期后，端口将删除该条目。当条目保留在表中时，端口不再向该目的地发送任何数据包（即，推迟表中未包含的其他目的地的流量）。当表中没有条目时，端口通过将数据包放在适当的VL输出队列中来传输数据包。</p><h2 id="寻址（Addressing）"><a href="#寻址（Addressing）" class="headerlink" title="寻址（Addressing）"></a>寻址（Addressing）</h2><p>每个端节点包含一个或多个通道适配器，每个通道适配器包含一个或者多个端口。此外，每个通道适配器都包含许多队列对（QP）。</p><p>每个QP具有由通道适配器分配的队列对编号（QPN），该队列对编号唯一地标识通道适配器内的QP。每个端口有两个众所周知的QP（QP0和QP1），所有其他QP都配置为通过特定端口进行操作。对于可靠的数据报服务，决定端口的是EE上下文而不是QP上下文。</p><p>原始数据报以外的数据包包含目标QP的QPN。当信道适配器接收到数据包时，它使用目标QPN(和EE上下文用于可靠数据报)的上下文来处理该分组。</p><p>每个端口都有由本地子网管理器(即子网管理器)分配的本地ID(LID)。在子网中，LID是唯一的。交换机使用LID在子网内路由数据包。本地子网管理器根据LID和该端口相对于特定交换机的位置配置交换机中的路由表。每个数据包都包含一个源LID(SLID)，用于标识将数据包注入子网的端口，以及一个目的LID(DLID)，用于标识结构将在其中传递数据包的端口。</p><p>IBA还通过定义LID Mask Control(LMC)在物理端口中提供多个虚拟端口。LMC指定在验证数据包DLID是否与分配的LID匹配时，物理端口屏蔽(忽略)的LID的最低有效位的数目。这些位不会被交换机忽略，因此子网管理器可以基于这些最低有效位编程通过Fabric的不同路径。因此，该端口似乎是2<sup>LMC</sup>端口，用于跨Fabric路由。</p><p>每个端口还至少有一个IPv6地址格式的全局ID(GID)。GID是全局唯一的。每个数据包可选地包含一个全局路由报文头(GRH)，指定一个源GID(SGID)，该源GID(SGID)标识将数据包注入到结构中的端口，以及一个目标GID(DGID)，该目标GID标识结构将在其中传递包的端口。路由器使用GRH在子网之间路由数据包。交换机忽略GRH。</p><p>每个通道适配器都有一个全局唯一标识符(GUID)，称为由通道适配器供应商分配的节点GUID。它的每个端口都有一个端口GUID，也是由通道适配器供应商分配的。端口GUID与本地子网前缀组合在一起成为端口的默认GID。</p><p>子网管理为LID&#x2F;GID解析服务提供GUID。因此，一个节点可以通过记住一个节点或端口GUID来持久地标识另一个节点。</p><p>QP的地址是端口地址(GID+LID)和QPN的组合。为了与QP通信，需要一个信息向量，包括端口地址(LID和&#x2F;或GID)、QPN、服务级别、路径MTU，以及可能的其他信息。此信息可通过发送到子网管理的路径查询请求获得。</p><p>服务ID用于解析QP。有些服务ID是众所周知的(即，某些功能具有指定的服务ID)，有些服务ID在I&#x2F;O控制器的服务条目列表中公布。子网管理器提供GID&#x2F;LID解析的GUID，但目标提供QP解析的服务ID作为通信管理过程的一部分。</p><p>一般来说，请求通信消息的目标节点使用服务ID将请求定向到实体，该实体决定是否继续进行通信建立。如果判定是肯定的，则目标返回建立通信所需的信息，其中包括QPN加上特定于传输服务类型的其他信息。</p><p>简化的地址解析过程如图20所示。</p><p><img src="/image/IBA%E5%8A%9F%E8%83%BD/image-20230715094305406.png#pic_center" alt="image-20230715094305406"></p><p>在图中，目标是一个I&#x2F;O控制器，在这里发起者通过查询IOC以获得支持的I&#x2F;O协议列表来学习服务ID。只有当正在建立的服务使用与管理MAD不同的路径特性(SL、QoS、MTU等)时，才需要第二个路径解析。</p><h2 id="多播（Multicast）"><a href="#多播（Multicast）" class="headerlink" title="多播（Multicast）"></a>多播（Multicast）</h2><p>多播是一种一对多&#x2F;多对多的通信模式，旨在简化和提高一组终端节点之间的通信效率。</p><p>每个多播组由唯一的GID标识。多播将通过一个端口为每个节点提供一个参与管理的端口。这些信息被分发到交换机。每个交换机都配置了多播通信的路由信息，该信息指定了分组需要传输的所有端口。注意确保不存在循环(即，单个生成树使得包不会转发到已经处理该包的交换机)。</p><p>节点在它发送给该多播组的所有数据包中使用多播LID和GID。当交换机接收到多播数据包(即，在数据包的DLID字段中有多播限制的数据包)时，它复制该数据包并将其发送到除到达端口之外的每个指定端口。以这种方式，每个级联交换机复制分组，使得分组仅到达每个订阅的端节点一次。</p><p>信道适配器可以限制可以为同一多播地址注册的QP的数量。通道适配器将多播数据包分发给为该多播地址注册的QP。一个QP可以为同一个端口的多个地址注册，但是如果使用者希望在多个端口上接收多播流量，则每个端口需要一个不同的QP。信道适配器通过分组的DLID或分组的目的地QP字段中的特殊值来识别多播分组，并将分组路由到为该地址和端口注册的QP。注意，多播数据包中的目的地QP字段不是QPN。</p><h3 id="多播示例"><a href="#多播示例" class="headerlink" title="多播示例"></a>多播示例</h3><p>图21举例说明了不可靠的多播IBA操作：</p><ul><li><p>在IBA路由元件(交换机或路由器)端口接收PSN&#x3D;1129的数据包。</p></li><li><p>交换&#x2F;路由组件检查包报文头并提取DLID&#x2F;多播GID以确定它是否对应于多播组。一个实现可以将该数据维护为其内部路由表的一部分，例如，对应于该分组应转发的输出端口的位掩码。</p></li><li><p>交换机或路由器复制数据包(取决于实现)，并将数据包转发到输出端口。</p></li></ul><p><img src="/image/IBA%E5%8A%9F%E8%83%BD/image-20230715095705041.png#pic_center" alt="image-20230715095705041"></p><h3 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h3><p>IBA没有定义多播组管理协议来实现加入和离开操作。然而，管理接口和相关的MAD用于实现多播组协议被指定。虽然这些机制是子网管理(SA)的一部分，但某些操作是由子网管理器(SM)隐式执行的。在下面的讨论中，术语多播管理实体用于描述SA&#x2F;SM关于多播管理的预期责任。有关详细信息，请参阅多播成员记录的子网管理属性。</p><h4 id="组播组创建"><a href="#组播组创建" class="headerlink" title="组播组创建"></a>组播组创建</h4><p>多播组的创建是IBA中的一个显式操作，目的是提供对<strong>组特征</strong>的单一控制，并允许成员进行颠覆性的加入。在能够成功加入组之前，必须由多播管理实体创建组：</p><p>1） (管理)应用程序定义(或确定)目标多播组地址(GID)。它指定特定的组特征(PMTU、P-Key等)，并通过调用多播管理实体的多播组创建(multicast group create)来创建多播组。此应用程序可以请求特定的多播GID或为其分配一个。</p><p>2）多播管理实体可以通知正在创建的新组(IBA V1.1中未定义)的子网上的适当路由器。路由器协议应该确定这个多播组是否在另一个子网中运行。如果是，路由器返回现有多播组的PMTU，以确定是否允许创建。</p><p>3）多播管理实体将多播组地址映射到多播LID。</p><h4 id="组播组加入"><a href="#组播组加入" class="headerlink" title="组播组加入"></a>组播组加入</h4><p>多播组加入算法(适用于IBA不可靠数据报多播组)定义如下：</p><ol><li>应用程序定义或确定目标多播组地址并调用多播加入操作。</li><li>底层join实现确定关联的端节点是否参与多播组。如果是，应用程序将建立一个新的本地QP并执行加入该组所需的步骤。否则，应用程序将调用管理接口与多播组管理实体通信。</li><li>多播管理实体在接收到加入请求时执行以下步骤：</li></ol><p>——a) 验证多播组地址——如果无效，则加入操作失败。</p><p>——b) 验证请求的PMTU——加入操作失败(如果无效)。</p><p>——c) 验证连接到端节点的交换机是否能够进行多播操作。交换机可以通过数据包复制支持多播操作，也可以配置为将所有多播数据包发送到端节点连接端口。</p><p>——d) 如果多播组地址当前在此子网内运行，请执行以下操作：</p><p>————i) 验证参与此多播组的所有交换机和路由器都能支持请求的PMTU。如果不能，则加入操作将失败。</p><p>————ii)每个多播组通过在参与交换机之间定义逻辑路由树来实现。重新生成&#x2F;修改路由树以包含新的端节点。多播管理实体通知结构管理更新所有交换机和路由器中的关联路由转发表，以反映此新拓扑。</p><p>——e) 如果多播组地址不在此子网内运行，请执行以下步骤。</p><p>————i) 通知此子网内的每个路由器加入操作。路由器协议应该确定这个多播组是否在另一个子网中运行。如果是这样，路由器返回现有多播组的PMTU，以确定是否允许创建和后续的加入操作。</p><p>————ii)将多播组地址映射到未使用的多播LID。</p><p>————iii)建立多播路由树，并相应地更新相关的交换机和路由器路由转发表。</p><p>————iv)创建组并将PMTU分配给多播组。</p><p>————v) 将多播LID和相关的组特征返回到端节点，并允许多播操作启动。</p><p>——f) 此子网中的每个路由器都被通知成功的多播加入操作。路由器调用适当的多播组管理操作来添加此子网作为参与关联多播组的成员。本协议不符合IBA规范。</p><ol start="4"><li>将成员添加到组中。</li></ol><h4 id="退出多播组"><a href="#退出多播组" class="headerlink" title="退出多播组"></a>退出多播组</h4><p>当应用程序离开多播组时，将使用以下算法：</p><ol><li>应用程序的QP作为多播组的目标被删除。如果仍有QP参与该多播组，则无需进一步操作。</li><li>如果在这个端口上没有更多的QP在多播组中参与，则退出实现通知多播管理实体该端节点不再参与该多播组。多播管理实体执行以下步骤：</li></ol><p>——a) 更新交换机和路由器路由转发表，以有效地删除此端节点作为与此多播组关联的数据包的目标。</p><p>——b) 从组中删除成员。</p><h4 id="删除多播组"><a href="#删除多播组" class="headerlink" title="删除多播组"></a>删除多播组</h4><p>当(管理)应用程序认为不需要多播组或没有其他端节点参与多播组时，可以删除该多播组。在接收到删除请求时，多播管理实体采取以下步骤：</p><ol><li>从多播组地址取消多播LID的映射。</li><li>通知此子网中的每个路由器此子网不再参与关联的多播组。</li></ol><h3 id="多播删减"><a href="#多播删减" class="headerlink" title="多播删减"></a>多播删减</h3><p>为了提高结构效率，多播组管理实体应定期验证参与多播组的所有终端节点和路由器仍在参与，如果没有，则应通过执行多播组离开算法将它们从多播组中删除。验证周期不在IBA的范围内。</p><h2 id="Verbs"><a href="#Verbs" class="headerlink" title="Verbs"></a>Verbs</h2><p>IBA描述了主机通道适配器和该主机通道适配器提供的I&#x2F;O服务的使用者之间的服务接口。向使用者公开的所需行为由一组称为Verb的语义来描述。Verbs描述基于向通道适配器提交工作请求并返回完成状态的特定队列模型在主机通道适配器和使用者之间发生的操作。</p><p>Verbs的目的不是指定API，而是充分描述接口，以允许定义API，从而允许I&#x2F;O服务的使用者充分利用该体系结构。</p><blockquote><p>翻译自《InfiniBand IB.Specification.Vol.1-Release-1.4-2020-04-07.3》3.5节。</p></blockquote><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>除了为原始数据报服务类型配置的QP0、QP1和QPs。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>RDMA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IBA</tag>
      
      <tag>RDMA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用网络协议与规范对应表</title>
    <link href="/2023/07/08/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%8E%E8%A7%84%E8%8C%83%E5%AF%B9%E5%BA%94%E8%A1%A8/"/>
    <url>/2023/07/08/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%8E%E8%A7%84%E8%8C%83%E5%AF%B9%E5%BA%94%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="协议对应表"><a href="#协议对应表" class="headerlink" title="协议对应表"></a>协议对应表</h2><table><thead><tr><th>协议所属层</th><th>协议缩写</th><th>协议英文全称</th><th>协议中文名</th><th>对应RFC文档</th></tr></thead><tbody><tr><td>应用层</td><td>COPS</td><td>Common Open Policy Service</td><td>公共开放策略服务</td><td>RFC 2748</td></tr><tr><td>应用层</td><td>FANP</td><td>Flow Attribute Notification Protocol</td><td>流属性通知协议</td><td>RFC 2129</td></tr><tr><td>应用层</td><td>Finger</td><td>User Information Protocol</td><td>用户信息协议</td><td>RFC 1194,1196,1228</td></tr><tr><td>应用层</td><td>FTP</td><td>File Transfer Protocol</td><td>文件传输协议</td><td>RFC 959</td></tr><tr><td>应用层</td><td>HTTP</td><td>Hypertext Transfer Protocol</td><td>超文本传输协议</td><td>RFC 1945,2616</td></tr><tr><td>应用层</td><td>IMAP4</td><td>Internet Message Access Protocol version 4</td><td>因特网信息访问协议第四版</td><td>RFC 1730</td></tr><tr><td>应用层</td><td>IMPP</td><td>Instant Messaging and Presence Protocol</td><td>即时信息表示协议</td><td>RFC 3861</td></tr><tr><td>应用层</td><td>IRC</td><td>Internet Relay Chat Protocol Internet</td><td>在线聊天协议</td><td>RFC 1459</td></tr><tr><td>应用层</td><td>ISAKMP</td><td>Internet Security Association and Key Management Protocol ? Interne</td><td>安全连接和密钥管理协议</td><td>RFC 2048</td></tr><tr><td>应用层</td><td>DNS</td><td>Domain Name System</td><td>域名系统</td><td>RFC 4343</td></tr><tr><td>应用层</td><td>DHCP</td><td>Dynamic Host Configuration Protocol</td><td>动态主机配置协议</td><td>RFC 2131</td></tr><tr><td>应用层</td><td>BOOTP</td><td>Bootstrap Protocol</td><td>引导协议</td><td>RFC 951</td></tr><tr><td>应用层</td><td>NTP</td><td>Network Time Protocol</td><td>网络时间协议</td><td>RFC 958</td></tr><tr><td>应用层</td><td>NNTP</td><td>Network News Transfer Protocol</td><td>网络新闻传输协议</td><td>RFC 977</td></tr><tr><td>应用层</td><td>POP3</td><td>Post Office Protocol version 3</td><td>邮局协议第三版</td><td>RFC 1939</td></tr><tr><td>应用层</td><td>Radius</td><td>Remote Authentication Dial In User Service</td><td>远程用户拨号认证服务协议</td><td>RFC 2138</td></tr><tr><td>应用层</td><td>RLOGIN</td><td>Remote Login</td><td>远程登陆协议</td><td>RFC 1258,1282</td></tr><tr><td>应用层</td><td>RTSP</td><td>Real-time Streaming Protocol</td><td>实时流协议</td><td>RFC 2326</td></tr><tr><td>应用层</td><td>SCTP</td><td>Stream Control Transmision Protocol</td><td>流控制传输协议</td><td>RFC 2960</td></tr><tr><td>应用层</td><td>S-HTTP</td><td>Secure Hypertext Transfer Protocol</td><td>安全超文本传输协议</td><td>RFC 2660</td></tr><tr><td>应用层</td><td>SLP</td><td>Service Location Protocol</td><td>服务定位协议</td><td>RFC 2165</td></tr><tr><td>应用层</td><td>SMTP</td><td>Simple Mail Transfer Protocol</td><td>简单邮件传输协议</td><td>RFC 821,2821</td></tr><tr><td>应用层</td><td>ICP</td><td>Internet Cache Protocol Internet</td><td>缓存协议</td><td>RFC 2186</td></tr><tr><td>应用层</td><td>SNMP</td><td>Simple Network Management Protocol</td><td>简单网络管理协议</td><td>RFC 1157</td></tr><tr><td>应用层</td><td>SOCKS</td><td>Socket Secure</td><td>安全套接字协议</td><td>RFC 1928</td></tr><tr><td>应用层</td><td>TACACS</td><td>Terminal Access Controller Access Control System</td><td>终端访问控制器访问控制系统协议</td><td>RFC 1492</td></tr><tr><td>应用层</td><td>TELNET</td><td>TCP&#x2F;IP Terminal Emulation Protocol</td><td>TCP&#x2F;IP终端仿真协议</td><td>RFC 854</td></tr><tr><td>应用层</td><td>TFTP</td><td>Trivial File Transfer Protocol</td><td>简单文件传输协议</td><td>RFC 1350</td></tr><tr><td>应用层</td><td>X-Window</td><td>X Window</td><td>X Window</td><td>RFC 1198</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>表示层</td><td>NBSSN</td><td>NetBIOS Session Service</td><td>NetBIOS会话服务协议</td><td>RFC 1001</td></tr><tr><td>表示层</td><td>LPP</td><td>LightWight Presentation Protocol</td><td>轻量级表示协议</td><td>RFC 1085</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>会话层</td><td>TLS</td><td>Transport Layer Security</td><td>传输层安全协议</td><td>RFC 2246</td></tr><tr><td>会话层</td><td>LDAP</td><td>Lightweight Directory Access Protocol</td><td>轻量级目录访问协议</td><td>RFC 1777</td></tr><tr><td>会话层</td><td>RPC</td><td>Remote Procedure Call protocol</td><td>远程过程调用协议</td><td>RFC 1050,1057,1831</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>传输层</td><td>Mobile</td><td>IP Mobile IP Protocol</td><td>移动IP协议</td><td>RFC 2002</td></tr><tr><td>传输层</td><td>RUDP</td><td>Reliable User Datagram Protocol</td><td>可靠的用户数据报协议</td><td>RFC 908,1151</td></tr><tr><td>传输层</td><td>TALI</td><td>Transport Adapter Layer Interface</td><td>传输适配层接口协议</td><td>RFC 3094</td></tr><tr><td>传输层</td><td>TCP</td><td>Transmission Control Protocol</td><td>传输控制协议</td><td>RFC 793</td></tr><tr><td>传输层</td><td>UDP</td><td>User Datagram Protocol</td><td>用户数据报协议</td><td>RFC 768</td></tr><tr><td>传输层</td><td>Van</td><td>Jacobson compressed TCP</td><td>压缩TCP协议</td><td>RFC 1144</td></tr><tr><td>传输层</td><td>XOT</td><td>X.25 over TCP</td><td>基于TCP之上的X.25协议</td><td>RFC 1613</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>网络层</td><td>EGP</td><td>Exterior Gateway Protocol</td><td>外部网关协议</td><td>RFC 827</td></tr><tr><td>网络层</td><td>OSPF</td><td>Open Shortest Path First</td><td>开放最短路径优先协议</td><td>RFC 2178,2328</td></tr><tr><td>网络层</td><td>DVMRP</td><td>Distance Vector Multicast Routing Protocol</td><td>距离矢量组播路由协议</td><td>RFC 1075</td></tr><tr><td>网络层</td><td>ICMP</td><td>Internet Control Message Protocol version 4</td><td>Internet控制信息协议</td><td>RFC 792</td></tr><tr><td>网络层</td><td>ICMPv6</td><td>Internet Control Message Protocol version 6</td><td>Internet控制信息协议第6版</td><td>RFC 1885,2463</td></tr><tr><td>网络层</td><td>IGMP</td><td>Internet Group Management Protocol</td><td>Internet组管理协议</td><td>RFC 1112, 2236,3376</td></tr><tr><td>网络层</td><td>IP</td><td>Internet Protocol version 4</td><td>互联网协议</td><td>RFC 791</td></tr><tr><td>网络层</td><td>NHRP</td><td>Next Hop Resolution Protocol</td><td>下一跳解析协议</td><td>RFC 2332</td></tr><tr><td>网络层</td><td>IPv6</td><td>Internet Protocol version 6</td><td>互联网协议第6版</td><td>RFC 1883,2460</td></tr><tr><td>网络层</td><td>MOSPF</td><td>Mulitcast Open Shortest Path First</td><td>组播开放最短路径优先协议</td><td>RFC 1585</td></tr><tr><td>网络层</td><td>PGM</td><td>Pragamatic General Mulitcast Protocol</td><td>实际通用组播协议</td><td>RFC 3208</td></tr><tr><td>网络层</td><td>PIM-SM</td><td>Protocol Independent Multicast-Sparse Mode</td><td>稀疏模式独立组播协议</td><td>RFC 2362</td></tr><tr><td>网络层</td><td>PIM-DM</td><td>Protocol Independent Multicast-Dense Mode</td><td>密集模式独立组播协议</td><td>RFC 3973</td></tr><tr><td>网络层</td><td>SLIP</td><td>Serial Line IP</td><td>串行线路IP协议</td><td>RFC 1055</td></tr><tr><td>网络层</td><td>MARS</td><td>Multicast Address Resolution Server</td><td>组播地址解析服务器协议</td><td>RFC 2022</td></tr><tr><td>网络层</td><td>RIP2</td><td>Routing Information Protocol version 2</td><td>路由信息协议第2版</td><td>RFC 2453</td></tr><tr><td>网络层</td><td>RIPng</td><td>for IPv6 Routing Information Protocol for IPv6</td><td>IPv6路由信息协议</td><td>RFC 2080</td></tr><tr><td>网络层</td><td>RSVP</td><td>Resource-Reservation Protocol</td><td>资源预留协议</td><td>RFC 2205,2750</td></tr><tr><td>网络层</td><td>VRRP</td><td>Virtual Router Redundancy Protocol</td><td>虚拟路由器冗余协议</td><td>RFC 2338,3768</td></tr><tr><td>网络层</td><td>AH</td><td>Authentication Header Protocol</td><td>认证头协议</td><td>RFC 2402</td></tr><tr><td>网络层</td><td>ESP</td><td>Encapsulating Security Payload</td><td>安全封装有效载荷协议</td><td>RFC 2406</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>数据链路层</td><td>ARP</td><td>Address Resolution Protocol</td><td>地址解析协议</td><td>RFC 826</td></tr><tr><td>数据链路层</td><td>RARP</td><td>Reverse Address Resolution Protocol</td><td>逆向地址解析协议</td><td>RFC 903</td></tr><tr><td>数据链路层</td><td>IARP</td><td>Inverse Address Resolution Protocol</td><td>逆向地址解析协议</td><td>RFC 2390</td></tr><tr><td>数据链路层</td><td>DCAP</td><td>Data Link Switching Client Access Protocol</td><td>数据转接客户访问协议</td><td>RFC 2114</td></tr><tr><td>数据链路层</td><td>MPLS</td><td>Multi-Protocol Label Switching</td><td>多协议标签交换协议</td><td>RFC 3031,3032</td></tr><tr><td>数据链路层</td><td>ATMP</td><td>Ascend Tunnel Management Protocol</td><td>接入隧道管理协议</td><td>RFC 2107</td></tr><tr><td>数据链路层</td><td>L2F</td><td>The Layer 2 Forwarding Protocol</td><td>第二层转发协议</td><td>RFC 2341</td></tr><tr><td>数据链路层</td><td>L2TP</td><td>Layer 2 Tunneling Protocol</td><td>第二层隧道协议</td><td>RFC 2661</td></tr><tr><td>数据链路层</td><td>PPTP</td><td>Point to Point Tunneling Protocol</td><td>点对点隧道协议</td><td>RFC 2637</td></tr></tbody></table><p>查询对应RFC文档网址：</p><p><a href="https://datatracker.ietf.org/doc/search?name=html&rfcs=on&activedrafts=on&olddrafts=on">Document Search (ietf.org)</a></p><h2 id="RFC对应表"><a href="#RFC对应表" class="headerlink" title="RFC对应表"></a>RFC对应表</h2><table><thead><tr><th>RFC</th><th>规范</th></tr></thead><tbody><tr><td>RFC1</td><td>主机软件</td></tr><tr><td>RFC2</td><td>主机软件</td></tr><tr><td>RFC3</td><td>文档规范</td></tr><tr><td>RFC4</td><td>网络时间表</td></tr><tr><td>RFC6</td><td>与 Bob Kahn 会话</td></tr><tr><td>RFC10</td><td>文档规范</td></tr><tr><td>RFC13</td><td>零文本长度的EOF信息</td></tr><tr><td>RFC16</td><td>M.I.T</td></tr><tr><td>RFC18</td><td>IMP-IMP和主机-主机控制联接</td></tr><tr><td>RFC19</td><td>可用来降低有限交换节点阻塞的两条协议性的建议</td></tr><tr><td>RFC20</td><td>用于网络交换的 ASCII 格式</td></tr><tr><td>RFC21</td><td>网络会议</td></tr><tr><td>RFC22</td><td>主机-主机控制信息格式</td></tr><tr><td>RFC23</td><td>多重传送的调节信息</td></tr><tr><td>RFC24</td><td>文档规范</td></tr><tr><td>RFC25</td><td>不使用高的连接号</td></tr><tr><td>RFC27</td><td>文档规范</td></tr><tr><td>RFC28</td><td>时间标准</td></tr><tr><td>RFC29</td><td>响应 RFC 28</td></tr><tr><td>RFC30</td><td>文档规范</td></tr><tr><td>RFC32</td><td>关于SRI所提议的实时时钟的一些想法</td></tr><tr><td>RFC34</td><td>关于ARC时钟的一些初步记录摘要</td></tr><tr><td>RFC35</td><td>网络会议</td></tr><tr><td>RFC36</td><td>协议注解</td></tr><tr><td>RFC37</td><td>网络会议结尾等</td></tr><tr><td>RFC38</td><td>NWG&#x2F;RFC 36 网络协议的注解</td></tr><tr><td>RFC40</td><td>关于未来协议的更多注解</td></tr><tr><td>RFC41</td><td>IMP-IMP 通讯信息</td></tr><tr><td>RFC42</td><td>信息数据类型</td></tr><tr><td>RFC43</td><td>被提议的会议</td></tr><tr><td>RFC45</td><td>关于未来协议的更多注解</td></tr><tr><td>RFC53</td><td>官方协议机构</td></tr><tr><td>RFC58</td><td>逻辑信息同步</td></tr><tr><td>RFC60</td><td>简单的 NCP 协议</td></tr><tr><td>RFC63</td><td>迟来的网络会议报告</td></tr><tr><td>RFC66</td><td>NIC - 第三级别的想法和其它噪音</td></tr><tr><td>RFC69</td><td>提议改变 主机&#x2F;IMP 规范来消除标记</td></tr><tr><td>RFC71</td><td>输入错误后的再分配</td></tr><tr><td>RFC72</td><td>建议改变网络协议延期执行</td></tr><tr><td>RFC73</td><td>响应 NWG&#x2F;RFC 67</td></tr><tr><td>RFC75</td><td>网络会议</td></tr><tr><td>RFC78</td><td>NCP状态报告:UCSB&#x2F;RAND</td></tr><tr><td>RFC79</td><td>圆木协议错误</td></tr><tr><td>RFC81</td><td>涉及信息的请求</td></tr><tr><td>RFC84</td><td>NWG&#x2F;RFC的1-80列表</td></tr><tr><td>RFC85</td><td>网络工作组会议</td></tr><tr><td>RFC90</td><td>CCN 作为一种网络服务中心</td></tr><tr><td>RFC99</td><td>网络会议</td></tr><tr><td>RFC101</td><td>对1971年2月17日伊利诺斯州的Urbana的网络工作组会议的注释</td></tr><tr><td>RFC102</td><td>主机-主机 协议故障清除委员会的说明</td></tr><tr><td>RFC103</td><td>中断键的执行</td></tr><tr><td>RFC104</td><td>连接 191</td></tr><tr><td>RFC105</td><td>通过 UCSB 进行远程登录和远程输出返回的网络说明书</td></tr><tr><td>RFC106</td><td>用户&#x2F;服务器 站点协议的网络主机问卷</td></tr><tr><td>RFC107</td><td>主机-主机 协议故障清除委员会的说明</td></tr><tr><td>RFC108</td><td>1971年2月17-19日在 Urbana 举行的 NWG 会议的人员列表</td></tr><tr><td>RFC124</td><td>在 RFC 107 中有印刷错误</td></tr><tr><td>RFC132</td><td>RFC 107 的排版错误</td></tr><tr><td>RFC148</td><td>RFC 123 的注释</td></tr><tr><td>RFC149</td><td>最好的铺设计划</td></tr><tr><td>RFC154</td><td>风格显示</td></tr><tr><td>RFC156</td><td>伊利诺斯州站点的状态: 响应 RFC 116</td></tr><tr><td>RFC179</td><td>连接的数字分配</td></tr><tr><td>RFC185</td><td>NIC 分发手册</td></tr><tr><td>RFC188</td><td>数据管理会议公告</td></tr><tr><td>RFC198</td><td>站点证明-林肯实验室 360&#x2F;67</td></tr><tr><td>RFC204</td><td>利用报路</td></tr><tr><td>RFC218</td><td>改变 IMP 状态报告设备</td></tr><tr><td>RFC228</td><td>澄清</td></tr><tr><td>RFC232</td><td>网络图形会议延缓</td></tr><tr><td>RFC245</td><td>预定网络工作组会议</td></tr><tr><td>RFC246</td><td>网络图形会议</td></tr><tr><td>RFC256</td><td>IMPSYS 变更通知</td></tr><tr><td>RFC276</td><td>NIC过程</td></tr><tr><td>RFC285</td><td>网络图形</td></tr><tr><td>RFC324</td><td>RJE 协议会议</td></tr><tr><td>RFC335</td><td>新界面 - IMP&#x2F;360</td></tr><tr><td>RFC348</td><td>放弃过程</td></tr><tr><td>RFC404</td><td>文件迁移协议的注释</td></tr><tr><td>RFC405</td><td>给 TIP 用户的第二封信</td></tr><tr><td>RFC456</td><td>UCSB 的数据重置服务</td></tr><tr><td>RFC457</td><td>FTP 的服务器与服务器交互</td></tr><tr><td>RFC496</td><td>IMP&#x2F;TIP 内存更新时间表(修订版 2)</td></tr><tr><td>RFC516</td><td>丢失消息的检测</td></tr><tr><td>RFC591</td><td>在 NVT ASCII UCSB和在线系统之间的实验输入映象</td></tr><tr><td>RFC621</td><td>“注意圣诞节的时候要把长袜挂在烟囱下面”</td></tr><tr><td>RFC628</td><td>更深的数据语言的设计观念</td></tr><tr><td>RFC634</td><td>最近的网络图</td></tr><tr><td>RFC637</td><td>SU-DSL网络地址的更改</td></tr><tr><td>RFC677</td><td>双重数据库的维护</td></tr><tr><td>RFC692</td><td>对于IMP&#x2F;HOST 协议的改动的注释 (RFCS 687 AND 690)</td></tr><tr><td>RFC697</td><td>FTP的CWD命令</td></tr><tr><td>RFC698</td><td>Telnet扩展ASCII选项</td></tr><tr><td>RFC763</td><td>角色邮箱</td></tr><tr><td>RFC775</td><td>面向目录的 FTP 命令</td></tr><tr><td>RFC779</td><td>Telnet发送-位置选项</td></tr><tr><td>RFC792</td><td>Internet 控制信息协议</td></tr><tr><td>RFC797</td><td>位图文件格式</td></tr><tr><td>RFC821</td><td>简单邮件传输协议</td></tr><tr><td>RFC826</td><td>以太网地址转换协议或转换网络协议地址</td></tr><tr><td>RFC827</td><td>Exterior 网关 协议 (EGP)</td></tr><tr><td>RFC854</td><td>Telnet协议说明书</td></tr><tr><td>RFC855</td><td>Telnet选项说明书</td></tr><tr><td>RFC856</td><td>Telnet二进制传输</td></tr><tr><td>RFC857</td><td>Telnet回声选项</td></tr><tr><td>RFC858</td><td>Telnet抑制前进选项</td></tr><tr><td>RFC859</td><td>Telnet状态选项</td></tr><tr><td>RFC860</td><td>Telnet定时标记选项</td></tr><tr><td>RFC861</td><td>Telnet扩展选项列表选项</td></tr><tr><td>RFC862</td><td>回声协议</td></tr><tr><td>RFC863</td><td>废除协议</td></tr><tr><td>RFC864</td><td>字符产生协议</td></tr><tr><td>RFC865</td><td>白天协议的引用</td></tr><tr><td>RFC866</td><td>激活用户</td></tr><tr><td>RFC867</td><td>白天协议</td></tr><tr><td>RFC868</td><td>时间协议</td></tr><tr><td>RFC872</td><td>局域网上的TCP协议</td></tr><tr><td>RFC877</td><td>IP 数据包通过公共数据网络的传输标准</td></tr><tr><td>RFC888</td><td>STUB Exterior Gateway Protocol</td></tr><tr><td>RFC890</td><td>外部网关协议执行表</td></tr><tr><td>RFC894</td><td>IP 数据包通过以太网网络传输标准</td></tr><tr><td>RFC895</td><td>IP 数据包通过试验性以太网网络的传输标准</td></tr><tr><td>RFC896</td><td>在IPTCP internet网络中的拥塞控制</td></tr><tr><td>RFC903</td><td>反向地址转换协议</td></tr><tr><td>RFC911</td><td>BERKELEY UNIX 4.2下的EGP网关</td></tr><tr><td>RFC917</td><td>因特网子网</td></tr><tr><td>RFC918</td><td>邮局协议</td></tr><tr><td>RFC925</td><td>多局域网地址解决</td></tr><tr><td>RFC930</td><td>Telnet终端类型选项</td></tr><tr><td>RFC932</td><td>子网地址分配方案</td></tr><tr><td>RFC937</td><td>邮局协议( 版本 2)</td></tr><tr><td>RFC948</td><td>IP 数据包通过IEEE 802.3 网络传输的两种方法</td></tr><tr><td>RFC949</td><td>FTP 未公开的独特命令</td></tr><tr><td>RFC951</td><td>引导协议(BOOTP)</td></tr><tr><td>RFC955</td><td>朝向一个处理过程应用的传输服务</td></tr><tr><td>RFC962</td><td>TCP-4 的最初</td></tr><tr><td>RFC968</td><td>“这是开动前的黑暗”</td></tr><tr><td>RFC974</td><td>邮件路由与域名系统</td></tr><tr><td>RFC975</td><td>自治联邦</td></tr><tr><td>RFC976</td><td>UUCP 邮件互换格式标准</td></tr><tr><td>RFC985</td><td>Internet 网关要求 - 起草</td></tr><tr><td>RFC988</td><td>主机扩展用于IP多点传送</td></tr><tr><td>RFC1050</td><td>RPC远程步骤呼叫协议说明书</td></tr><tr><td>RFC1055</td><td>在串行线路上传输IP数据报的非标准协议</td></tr><tr><td>RFC1057</td><td>RPC远程步骤呼叫协议说明书版本 2</td></tr><tr><td>RFC1073</td><td>Telnet窗口大小选项</td></tr><tr><td>RFC1075</td><td>远距离矢量多播选路协议</td></tr><tr><td>RFC1088</td><td>IP 数据包传输通过NetBIOS网络的标准</td></tr><tr><td>RFC1090</td><td>SMTP在X.25</td></tr><tr><td>RFC1091</td><td>TelnetTELNET终端类型选项</td></tr><tr><td>RFC1094</td><td>NFS网络文件系统协议说明书</td></tr><tr><td>RFC1096</td><td>Telnet X 显示定位选项</td></tr><tr><td>RFC1097</td><td>Telnet潜意识-信息选项</td></tr><tr><td>RFC1112</td><td>主机扩展用于IP多点传送</td></tr><tr><td>RFC1113</td><td>Internet电子邮件秘密增强第一部分- 信息加密和身份验证步骤</td></tr><tr><td>RFC1131</td><td>OSPF规范</td></tr><tr><td>RFC1132</td><td>802．2分组在IPX网络上传输的标准</td></tr><tr><td>RFC1134</td><td>+PPP协议：关于在点到点链路上进行多协议包传送的建议</td></tr><tr><td>RFC1142</td><td>OSI IS-IS 域内路由协议</td></tr><tr><td>RFC1144</td><td>低速串行链路上的TCPIP头部压缩</td></tr><tr><td>RFC1145</td><td>SNMPv2的管理模型</td></tr><tr><td>RFC1155</td><td>基于TCPIP网络的管理结构和标记</td></tr><tr><td>RFC1166</td><td>Internet数字</td></tr><tr><td>RFC1180</td><td>TCPIP指南</td></tr><tr><td>RFC1191</td><td>路径MTU探索</td></tr><tr><td>RFC1215</td><td>为使用SNMP定义Trap的惯例</td></tr><tr><td>RFC1239</td><td>试验管理系统库(MIB)到标准管理系统库(MIB)的重分配</td></tr><tr><td>RFC1242</td><td>基准术语用于网络互连设备</td></tr><tr><td>RFC1258</td><td>BSD 的远程登录</td></tr><tr><td>RFC1287</td><td>未来的Internet 体系结构</td></tr><tr><td>RFC1288</td><td>Finger用户信息协议</td></tr><tr><td>RFC1298</td><td>基于IPX协议的SNMP</td></tr><tr><td>RFC1321</td><td>MD5 信息-摘要算</td></tr><tr><td>RFC1332</td><td>PPP Internet 协议控制协议 (IPCP)</td></tr><tr><td>RFC1333</td><td>PPP 链接质量监控</td></tr><tr><td>RFC1355</td><td>网络中心数据库的保密和准确性问题</td></tr><tr><td>RFC1365</td><td>一种IP地址扩展提议</td></tr><tr><td>RFC1370</td><td>OSPF适用范围声明</td></tr><tr><td>RFC1387</td><td>RIP（版本2）协议分析</td></tr><tr><td>RFC1388</td><td>RIP协议版本2</td></tr><tr><td>RFC1393</td><td>Traceroute使用IP选项</td></tr><tr><td>RFC1397</td><td>在边界网关协议（Border Gateway Protocol）版本2</td></tr><tr><td>RFC1408</td><td>Telnet环境选项</td></tr><tr><td>RFC1413</td><td>鉴定协议</td></tr><tr><td>RFC1414</td><td>身份识别管理系统库(MIB)</td></tr><tr><td>RFC1418</td><td>SNMP优于OSI</td></tr><tr><td>RFC1420</td><td>SNMP优于IPX</td></tr><tr><td>RFC1426</td><td>SMTP服务扩展用于8bit-多用途网际邮件扩充协议(MIME)传输</td></tr><tr><td>RFC1428</td><td>Internet邮件从Just-Send-8到8bit-SMTPMIME的转换</td></tr><tr><td>RFC1433</td><td>直接ARP</td></tr><tr><td>RFC1445</td><td>简单网络管理协议(SNMPv2)版本 2的管理模式</td></tr><tr><td>RFC1454</td><td>下一代IP提议的比较</td></tr><tr><td>RFC1461</td><td>通过X.25多协议互连SNMP管理系统库(MIB)扩展</td></tr><tr><td>RFC1469</td><td>通过令牌－环局域网的IP多点传送</td></tr><tr><td>RFC1483</td><td>通过ATM适应层5的多协议封装</td></tr><tr><td>RFC1558</td><td>LDAP研究过滤器的字符串表达</td></tr><tr><td>RFC1571</td><td>Telnet环境选项互用性问题</td></tr><tr><td>RFC1590</td><td>媒体类型注册过程</td></tr><tr><td>RFC1591</td><td>域名系统的结构和授权</td></tr><tr><td>RFC1597</td><td>私有Internet的地址分配</td></tr><tr><td>RFC1605</td><td>SONET to Sonnet翻译</td></tr><tr><td>RFC1606</td><td>用IP版本9的历史观</td></tr><tr><td>RFC1611</td><td>DNS服务器MIB扩展</td></tr><tr><td>RFC1612</td><td>DNS解析器MIB扩展</td></tr><tr><td>RFC1618</td><td>ISDN上的PPP(点对点)协议</td></tr><tr><td>RFC1628</td><td>UPS 管理信息基础</td></tr><tr><td>RFC1633</td><td>Internet 体系结构中的综合服务概述</td></tr><tr><td>RFC1635</td><td>怎样使用匿名FTP</td></tr><tr><td>RFC1636</td><td>IAB工厂关于在Internet体系结构的安全报告 -2月8-10号, 1994</td></tr><tr><td>RFC1643</td><td>以太网-类似界面类型的管理对象的定义</td></tr><tr><td>RFC1658</td><td>字符流设备使用SMIv2管理对象的定义</td></tr><tr><td>RFC1661</td><td>点对点协议(PPP)</td></tr><tr><td>RFC1671</td><td>向IPng 过渡和其他考虑的白皮书</td></tr><tr><td>RFC1690</td><td>Internet工程与计划组（IEPG）介绍</td></tr><tr><td>RFC1691</td><td>康奈尔大学数字图书馆文档体系结构</td></tr><tr><td>RFC1696</td><td>用SMIv2定义的调制解调器MIB</td></tr><tr><td>RFC1713</td><td>DNS调试工具</td></tr><tr><td>RFC1715</td><td>地址分配效率比率H</td></tr><tr><td>RFC1723</td><td>路由信息协议（版本2）</td></tr><tr><td>RFC1724</td><td>RIP 版本 2 管理系统库(MIB) 扩展</td></tr><tr><td>RFC1738</td><td>统一资源定位器(URL)</td></tr><tr><td>RFC1752</td><td>推荐IP下一代协议</td></tr><tr><td>RFC1769</td><td>简单网络时间协议(SNTP)</td></tr><tr><td>RFC1771</td><td>边界网关协议版本4（BGP-4）</td></tr><tr><td>RFC1776</td><td>地址是信息</td></tr><tr><td>RFC1777</td><td>轻量级目录访问协议</td></tr><tr><td>RFC1787</td><td>在多供应Internet上的软件路由</td></tr><tr><td>RFC1796</td><td>不是所有RFCs是标准</td></tr><tr><td>RFC1797</td><td>A级子网实验</td></tr><tr><td>RFC1810</td><td>报告MD5性能</td></tr><tr><td>RFC1818</td><td>最好最新的实践</td></tr><tr><td>RFC1822</td><td>使用具备Photuris技术的指定IBM专利的权利的授予</td></tr><tr><td>RFC1823</td><td>LDAP 应用程序界面</td></tr><tr><td>RFC1827</td><td>IP 密码安全有效载荷 (ESP)</td></tr><tr><td>RFC1828</td><td>使用键控MD5进行IP鉴别</td></tr><tr><td>RFC1860</td><td>IPv4变量长度子网表</td></tr><tr><td>RFC1867</td><td>HTML中基于表单的文件上传</td></tr><tr><td>RFC1869</td><td>SMTP服务扩展</td></tr><tr><td>RFC1878</td><td>变量长度子网表格用于IPv4</td></tr><tr><td>RFC1881</td><td>IPv6 地址分配管理</td></tr><tr><td>RFC1883</td><td>Internet协议,版本6(IPv6)说明书</td></tr><tr><td>RFC1886</td><td>DNS扩展支持IP版本6</td></tr><tr><td>RFC1901</td><td>基于社区的SNMPv2介绍</td></tr><tr><td>RFC1904</td><td>简单网络管理协议(SNMPv2)版本 2的一致声明</td></tr><tr><td>RFC1918</td><td>个人Internets的地址分配</td></tr><tr><td>RFC1928</td><td>SOCKS V5的用户名&#x2F;密码鉴定</td></tr><tr><td>RFC1930</td><td>自治系统(AS)创建,选择,和注册的指导方针</td></tr><tr><td>RFC1939</td><td>邮局办公协议-版本3</td></tr><tr><td>RFC1942</td><td>HTML表格</td></tr><tr><td>RFC1945</td><td>超文本传输协议–HTTP&#x2F;1.0</td></tr><tr><td>RFC1956</td><td>在MIL域中注册</td></tr><tr><td>RFC1957</td><td>邮局协议(POP3)执行的一些观察</td></tr><tr><td>RFC1962</td><td>PPP压缩控制协议 (CCP)</td></tr><tr><td>RFC1977</td><td>PPP BSD 压缩协议</td></tr><tr><td>RFC1979</td><td>PPP压缩协议</td></tr><tr><td>RFC1981</td><td>IP 版本 6的路径MTU探索</td></tr><tr><td>RFC1982</td><td>序列号算法</td></tr><tr><td>RFC1988</td><td>有条件地授予权利给特殊的HP专利于连接Internet工程特遣队的Internet-标准网络管理框架中</td></tr><tr><td>RFC1993</td><td>PPP G和alf FZA 压缩 协议</td></tr><tr><td>RFC1994</td><td>PPP挑战握手身份验证协议 (CHAP)</td></tr><tr><td>RFC1997</td><td>BGP 组属性</td></tr><tr><td>RFC1998</td><td>BGP 社区属性在多本地路由中的应用</td></tr><tr><td>RFC2002</td><td>IP移动性支持</td></tr><tr><td>RFC2003</td><td>在IP内封装IP</td></tr><tr><td>RFC2004</td><td>IP最小封装</td></tr><tr><td>RFC2005</td><td>IP移动性的适用性陈述</td></tr><tr><td>RFC2011</td><td>SNMPv2 管理信息基础用于Internet 协议使用SMIv2</td></tr><tr><td>RFC2012</td><td>SNMPv2 管理信息基础 用于传输控制协议使用SMIv2</td></tr><tr><td>RFC2013</td><td>有关采用SMIv2用户数据报协议的SNMPv2管理信息数据库</td></tr><tr><td>RFC2015</td><td>多用途网际邮件扩充协议(MIME)安全具有相当好的保密性(PGP)</td></tr><tr><td>RFC2021</td><td>远程网络监控管理信息基础 版本 2使用SMIv2</td></tr><tr><td>RFC2025</td><td>简单公共密钥GSS-API机制（SPKM）</td></tr><tr><td>RFC2040</td><td>RC5, RC5-CBC, RC5-CBC-Pad,和 RC5-CTS算法</td></tr><tr><td>RFC2042</td><td>注册新BGP属性类型</td></tr><tr><td>RFC2046</td><td>多用途Internet邮件扩展(多用途网际邮件扩充协议(MIME))第二部分:媒体类型</td></tr><tr><td>RFC2053</td><td>AM (美国)域</td></tr><tr><td>RFC2078</td><td>通用安全服务应用接口（GSS-API） V2</td></tr><tr><td>RFC2079</td><td>X.500 属性类型和对象类别去掌握统一资源定位器(URIs)的定义</td></tr><tr><td>RFC2085</td><td>具有重放预防的HMAC-MD5 IP 身份验证</td></tr><tr><td>RFC2088</td><td>IMAP4非同步字符</td></tr><tr><td>RFC2095</td><td>简单挑战&#x2F;回应的IMAP&#x2F;POP授权扩展</td></tr><tr><td>RFC2096</td><td>IP面向表格管理系统库(MIB)</td></tr><tr><td>RFC2101</td><td>IPv4 今天地址行为</td></tr><tr><td>RFC2104</td><td>HMAC:键入-散列法用于信息身份验证</td></tr><tr><td>RFC2105</td><td>CCisco 系统的标签交换体系结构纵览</td></tr><tr><td>RFC2113</td><td>IP路由器警告选项</td></tr><tr><td>RFC2118</td><td>微软点对点压缩(MPPC)协议</td></tr><tr><td>RFC2119</td><td>关键字用于使用在RFCs指出要求水平</td></tr><tr><td>RFC2128</td><td>拨号控制MIB（SMIv2）</td></tr><tr><td>RFC2144</td><td>CAST-128 加密算法</td></tr><tr><td>RFC2147</td><td>TCP和UDP通过IPv6 Jumbograms</td></tr><tr><td>RFC2198</td><td>多余音频数据的RTP有效载荷</td></tr><tr><td>RFC2208</td><td>资源预留协议(RSVP)——版本1 适用性声明 关于配置的一些指导</td></tr><tr><td>RFC2212</td><td>有保证的质量服务说明书</td></tr><tr><td>RFC2213</td><td>综合服务管理信息基础使用SMI版本2</td></tr><tr><td>RFC2217</td><td>TelnetCom端口控制选项</td></tr><tr><td>RFC2221</td><td>IMAP4 登陆参考</td></tr><tr><td>RFC2228</td><td>FTP 安全扩展</td></tr><tr><td>RFC2234</td><td>语法说明书的扩充BNF:ABNF</td></tr><tr><td>RFC2236</td><td>Internet组管理协议,版本2</td></tr><tr><td>RFC2241</td><td>Novell目录服务的DHCP选项</td></tr><tr><td>RFC2245</td><td>匿名SASL机制</td></tr><tr><td>RFC2260</td><td>可升级支持用于多目录多供应者的连通</td></tr><tr><td>RFC2279</td><td>UTF-8,ISO 10646的一种转换格式</td></tr><tr><td>RFC2281</td><td>Cisco热备份路由协议（HSRP）</td></tr><tr><td>RFC2283</td><td>BGP-4的多协议扩展</td></tr><tr><td>RFC2284</td><td>PPP可扩展认证协议</td></tr><tr><td>RFC2289</td><td>一种一次性密码系统</td></tr><tr><td>RFC2296</td><td>HTTP 远程变量选择算法–RVSA&#x2F;1.0</td></tr><tr><td>RFC2313</td><td>PKCS#1：RSA加密 版本1.5</td></tr><tr><td>RFC2330</td><td>IP 执行规则的管理</td></tr><tr><td>RFC2343</td><td>应用于捆绑的MPEG的RTP有效载荷的格式</td></tr><tr><td>RFC2344</td><td>移动IP反向隧道</td></tr><tr><td>RFC2349</td><td>TFTP 休息间隔和传输大小选项</td></tr><tr><td>RFC2367</td><td>PF_KEY键管理 API,版本 2</td></tr><tr><td>RFC2372</td><td>处理Internet协议（TIP）-要求和补充信息</td></tr><tr><td>RFC2373</td><td>IPv6寻址体系结构</td></tr><tr><td>RFC2374</td><td>IPv6 可集聚全球单播地址格式</td></tr><tr><td>RFC2379</td><td>RSVP通过ATM执行的指导方针</td></tr><tr><td>RFC2384</td><td>POP URL 方案</td></tr><tr><td>RFC2393</td><td>IP有效载荷压缩协议(IPComp)</td></tr><tr><td>RFC2394</td><td>IP有效载荷压缩使用DEFLATE</td></tr><tr><td>RFC2401</td><td>Internet 协议的安全体系结构</td></tr><tr><td>RFC2403</td><td>在ESP和AH中使用HMAC-MD5-96</td></tr><tr><td>RFC2404</td><td>在ESP和AH中使用HMAC-SHA-1-96</td></tr><tr><td>RFC2406</td><td>IP 封装安全有效载荷 (ESP)</td></tr><tr><td>RFC2407</td><td>Internet IP 用于解释ISAKMP的安全域</td></tr><tr><td>RFC2408</td><td>Internet 安全关联和键管理协议 (ISAKMP)</td></tr><tr><td>RFC2409</td><td>Internet密钥交换（IKE）</td></tr><tr><td>RFC2410</td><td>NULL加密算法及其在IPsec协议中的应用</td></tr><tr><td>RFC2411</td><td>IP安全文件指南</td></tr><tr><td>RFC2412</td><td>OAKLEY 键决定协议</td></tr><tr><td>RFC2413</td><td>Dublin核心元数据用于资源发掘</td></tr><tr><td>RFC2435</td><td>针对JPEG压缩视频的RTP荷载格式</td></tr><tr><td>RFC2449</td><td>POP3 扩展机制</td></tr><tr><td>RFC2451</td><td>ESP CBC-模式密码算法</td></tr><tr><td>RFC2459</td><td>Internet X.509 公钥基础设施:证书和CRL简介</td></tr><tr><td>RFC2460</td><td>Internet协议,版本6(IPv6)说明书</td></tr><tr><td>RFC2463</td><td>针对因特网协议第六版(Ipv6)的因特网控制报文协议(ICMPv6)规范</td></tr><tr><td>RFC2466</td><td>IP 版本6 管理信息基础:ICMPv6组</td></tr><tr><td>RFC2471</td><td>IPv6检测地址分配</td></tr><tr><td>RFC2474</td><td>IPv4与IPv6包头中差分服务字段（DS Field）的定义</td></tr><tr><td>RFC2475</td><td>分类业务的体系结构</td></tr><tr><td>RFC2492</td><td>IPv6 通过ATM网络</td></tr><tr><td>RFC2495</td><td>有关 DS1,E1,DS2,E2接口类型的管理部件的定义</td></tr><tr><td>RFC2508</td><td>低速串行链路下IP&#x2F;UDP&#x2F;RTP数据包头的压缩</td></tr><tr><td>RFC2511</td><td>Internet X.509认证请求消息格式</td></tr><tr><td>RFC2516</td><td>在以太网上传输PPP的方法（PPPoE）</td></tr><tr><td>RFC2526</td><td>IPv6保留的子网任意传送地址</td></tr><tr><td>RFC2541</td><td>DNS 安全操作考虑</td></tr><tr><td>RFC2547</td><td>BGP&#x2F;MPLS ×××s</td></tr><tr><td>RFC2554</td><td>SMTP服务认证扩展</td></tr><tr><td>RFC2560</td><td>x.509因特网公钥基础设施在线证书状态协议——OCSP</td></tr><tr><td>RFC2570</td><td>标准互联网络管理框架第三版介绍</td></tr><tr><td>RFC2577</td><td>FTP 安全考虑</td></tr><tr><td>RFC2581</td><td>TCP拥塞控制</td></tr><tr><td>RFC2582</td><td>TCP的快速恢复算法NewReno修正</td></tr><tr><td>RFC2585</td><td>Internet X.509 公共键底部结构操作协议: FTP和HTTP</td></tr><tr><td>RFC2597</td><td>确定的面向PHB组</td></tr><tr><td>RFC2598</td><td>面向加速PHB</td></tr><tr><td>RFC2618</td><td>RADIUS 身份验证客户端管理系统库(MIB)</td></tr><tr><td>RFC2629</td><td>用XML 写I-Ds 和 RFC文档</td></tr><tr><td>RFC2633</td><td>S&#x2F;多用途网际邮件扩充协议(MIME) 版本 3 信息说明书</td></tr><tr><td>RFC2644</td><td>更改直接广播在路由器上的缺省值</td></tr><tr><td>RFC2669</td><td>DOCSIS 电缆设备管理系统库(MIB)电缆设备管理信息基础用于DOCSIS 适应性电缆调制解调器和电缆调制解调器中断系统</td></tr><tr><td>RFC2670</td><td>音频频率(RF)界面管理信息基础用于MCNS&#x2F;DOCSIS适应性RF界面</td></tr><tr><td>RFC2685</td><td>虚拟专用网标志符</td></tr><tr><td>RFC2702</td><td>基于MPLS的流量工程要求</td></tr><tr><td>RFC2706</td><td>ECML v1:电子商务字段名</td></tr><tr><td>RFC2713</td><td>LDAP（轻型目录存取协议）目录中JAVATM对象的表征模式</td></tr><tr><td>RFC2714</td><td>LDAP（轻型目录存取协议）目录中的CORBA对象参考方案</td></tr><tr><td>RFC2731</td><td>Dublin核心元数据在HTML上的编码</td></tr><tr><td>RFC2732</td><td>文本IPv6地址在URL上的格式</td></tr><tr><td>RFC2733</td><td>RTP有效载荷格式用于普通正向错误更正</td></tr><tr><td>RFC2736</td><td>RTP有效载荷格式说明书作者的指导方针</td></tr><tr><td>RFC2754</td><td>RPS IANA的发布</td></tr><tr><td>RFC2756</td><td>超文本缓存协议(HTCP&#x2F;0.0)</td></tr><tr><td>RFC2764</td><td>IP ×××的框架体系</td></tr><tr><td>RFC2773</td><td>使用KEA和SKIPJACK加密</td></tr><tr><td>RFC2774</td><td>HTTP 扩展框架</td></tr><tr><td>RFC2781</td><td>UTF-16,ISO 10646的一种编码</td></tr><tr><td>RFC2784</td><td>通用路由封装（GRE）</td></tr><tr><td>RFC2788</td><td>网络服务监视MIB</td></tr><tr><td>RFC2793</td><td>用于文本交谈的RTP负载</td></tr><tr><td>RFC2796</td><td>BGP路由映象</td></tr><tr><td>RFC2809</td><td>通过RADIUS的L2TP强制通道的执行</td></tr><tr><td>RFC2810</td><td>Internet 延迟交谈:体系结构</td></tr><tr><td>RFC2811</td><td>Internet延迟交谈：通道管理</td></tr><tr><td>RFC2813</td><td>Internet 延迟交谈:服务器协议</td></tr><tr><td>RFC2817</td><td>在HTTP&#x2F;1.1中升级到TLS</td></tr><tr><td>RFC2818</td><td>TLS之上的HTTP</td></tr><tr><td>RFC2824</td><td>呼叫过程语言框架和要求</td></tr><tr><td>RFC2825</td><td>复杂网络:I18N的发布,域名,和其它Internet协议</td></tr><tr><td>RFC2829</td><td>LDAP的身份验证方法</td></tr><tr><td>RFC2830</td><td>轻量级目录访问协议(v3): 传输层安全扩展</td></tr><tr><td>RFC2833</td><td>用于DTMF数字信号、电话音和电话信号的RTP负载格式</td></tr><tr><td>RFC2854</td><td>text&#x2F;html 媒体类型</td></tr><tr><td>RFC2855</td><td>IEEE 1394的DHCP</td></tr><tr><td>RFC2861</td><td>TCP 拥塞窗口检验</td></tr><tr><td>RFC2862</td><td>用于实时指针的RTP负载格式</td></tr><tr><td>RFC2866</td><td>RADIUS（远程用户拨号认证系统）记帐协议</td></tr><tr><td>RFC2867</td><td>RADIUS 账目管理修改用于通道协议支持</td></tr><tr><td>RFC2868</td><td>RADIUS 属性用于协议支持</td></tr><tr><td>RFC2869</td><td>RADIUS 扩展</td></tr><tr><td>RFC2871</td><td>一个IP电话路由框架</td></tr><tr><td>RFC2873</td><td>在Ipv4优先域中的TCP过程</td></tr><tr><td>RFC2874</td><td>支持IPv6地址集合和重编号的DNS 扩展</td></tr><tr><td>RFC2882</td><td>网络访问服务要求: 扩展范围实践</td></tr><tr><td>RFC2887</td><td>可靠的多点传送设计空间用于大的数据传送</td></tr><tr><td>RFC2889</td><td>基准方法论用于局域网交换设备</td></tr><tr><td>RFC2890</td><td>GRE中Key和SequenceNumber扩展</td></tr><tr><td>RFC2893</td><td>IPv6 主机和软件路由器转换机制</td></tr><tr><td>RFC2898</td><td>PKCS #5: 基于密码的密码系统说明书 版本 2.0. B</td></tr><tr><td>RFC2906</td><td>AAA 授权要求</td></tr><tr><td>RFC2914</td><td>拥塞控制原理</td></tr><tr><td>RFC2917</td><td>核心 MPLS IP ××× 体系结构</td></tr><tr><td>RFC2918</td><td>BGP-4（边界网关协议）的路由刷新功能</td></tr><tr><td>RFC2920</td><td>SMTP 针对命令流水线的服务扩展</td></tr><tr><td>RFC2923</td><td>TCP的路径MTU发现问题</td></tr><tr><td>RFC2932</td><td>IPv4 多点传送路由管理系统库(MIB)</td></tr><tr><td>RFC2935</td><td>Internet开放贸易协议(IOTP)HTTP 补充</td></tr><tr><td>RFC2939</td><td>新DHCP选项和信息类型的定义步骤和IANA指导方针</td></tr><tr><td>RFC2945</td><td>SRP身份验证和键交换系统</td></tr><tr><td>RFC2946</td><td>Telnet 数据加密选项</td></tr><tr><td>RFC2947</td><td>Telnet加密：DES3 64位密码回馈</td></tr><tr><td>RFC2948</td><td>Telnet加密：DES3 64位输出回馈</td></tr><tr><td>RFC2949</td><td>Telnet加密:CAST-128 64比特输出回馈</td></tr><tr><td>RFC2950</td><td>Telnet加密:CAST-128 64比特密码回馈</td></tr><tr><td>RFC2951</td><td>使用KEA和SKIPJACK进行TELNET身份验证</td></tr><tr><td>RFC2952</td><td>Telnet加密：DES 64位密码回馈</td></tr><tr><td>RFC2953</td><td>Telnet加密:DES 64比特输出回馈</td></tr><tr><td>RFC2957</td><td>The 应用&#x2F;whoispp-请求目录-类型</td></tr><tr><td>RFC2958</td><td>The 应用&#x2F;whoispp-回答目录-类型</td></tr><tr><td>RFC2959</td><td>实时传输协议管理信息库</td></tr><tr><td>RFC2964</td><td>超文本传输协议(HTTP)状态管理的应用</td></tr><tr><td>RFC2971</td><td>Internet信息访问协议(IMAP4)的标识符扩展</td></tr><tr><td>RFC2976</td><td>SIP信息方法</td></tr><tr><td>RFC2983</td><td>有区别的协议和通道</td></tr><tr><td>RFC2984</td><td>CAST-128密码算法在CMS中的使用</td></tr><tr><td>RFC2987</td><td>字符集注册和语言媒体特征标签</td></tr><tr><td>RFC2988</td><td>计算TCP重传时间的定时器</td></tr><tr><td>RFC2991</td><td>多路径分发在Unicast上和多点传送下一路程段选择</td></tr><tr><td>RFC2992</td><td>等值多-路径算法的分析</td></tr><tr><td>RFC2994</td><td>MISTY1加密算法的描述</td></tr><tr><td>RFC3001</td><td>对象标识符的URN名称空间</td></tr><tr><td>RFC3003</td><td>audio&#x2F;mpeg 媒体类型</td></tr><tr><td>RFC3005</td><td>IETF 讨论列表许可证</td></tr><tr><td>RFC3007</td><td>安全的域名系统动态更新</td></tr><tr><td>RFC3009</td><td>奇偶向前纠错 MIME类型的注册</td></tr><tr><td>RFC3012</td><td>移动IP的询问&#x2F;应答扩展机制</td></tr><tr><td>RFC3014</td><td>提示日志 管理系统库(MIB)</td></tr><tr><td>RFC3016</td><td>用于MPEG-4视听流的RTP负载格式</td></tr><tr><td>RFC3018</td><td>统一内存空间协议说明书</td></tr><tr><td>RFC3019</td><td>IP 版本 6 管理信息基础用于多点传送听众探索协议</td></tr><tr><td>RFC3021</td><td>在Ipv4点对点连接中使用31位前缀</td></tr><tr><td>RFC3022</td><td>传统IP网络地址转换（传统NAT）</td></tr><tr><td>RFC3026</td><td>在ENUM上联络到IETF&#x2F;ISOC</td></tr><tr><td>RFC3028</td><td>滤网:一种邮件过滤语言</td></tr><tr><td>RFC3029</td><td>Internet X.509 公共键下部构造数据有效性和认证服务协议</td></tr><tr><td>RFC3032</td><td>MPLS标记栈编码</td></tr><tr><td>RFC3033</td><td>信息域和协议标识符在Q.2941普通标识符和Q.2957用户对用户发送信号中的分配用于Internet 协议</td></tr><tr><td>RFC3034</td><td>标签转换在帧中继网络说明书中的使用</td></tr><tr><td>RFC3035</td><td>MPLS使用LD和ATM VC交换</td></tr><tr><td>RFC3037</td><td>LDP 的适用性</td></tr><tr><td>RFC3038</td><td>VCID提示通过ATM链接用于LDP</td></tr><tr><td>RFC3040</td><td>Internet网复制和缓存分类法</td></tr><tr><td>RFC3042</td><td>使用有限传输增强TCP的丢失恢复能力</td></tr><tr><td>RFC3043</td><td>Network Solutions的个人网络名(PIN): 一种个人和组织的统一资源名域</td></tr><tr><td>RFC3044</td><td>在ISSN-URN命名空间中用ISSN作为URN</td></tr><tr><td>RFC3046</td><td>DHCP 中继代理信息选项</td></tr><tr><td>RFC3048</td><td>可靠的多点传输建立阻止一对多大数据传送</td></tr><tr><td>RFC3051</td><td>IP有效载荷压缩使用ITU-T V.44打包方法</td></tr><tr><td>RFC3055</td><td>PINT服务体系结构管理信息基础.</td></tr><tr><td>RFC3058</td><td>IDEA加密算法在CMS上的使用</td></tr><tr><td>RFC3059</td><td>服务定位协议的属性列表扩展</td></tr><tr><td>RFC3061</td><td>对象标识符的一种URN姓名空间</td></tr><tr><td>RFC3062</td><td>LDAP口令修改扩展操作</td></tr><tr><td>RFC3066</td><td>语言鉴定标签</td></tr><tr><td>RFC3067</td><td>TERENA’S事件对象描述和转换格式要求</td></tr><tr><td>RFC3069</td><td>VLAN聚合实现IP地址有效分配</td></tr><tr><td>RFC3070</td><td>基于帧中继的第二层隧道协议</td></tr><tr><td>RFC3072</td><td>结构化的数据改变格式 (SDXF)</td></tr><tr><td>RFC3074</td><td>DHC加载平衡算法</td></tr><tr><td>RFC3078</td><td>微软点对点加密(MPPE)协议</td></tr><tr><td>RFC3081</td><td>将区块扩展交换协议（BEEP）核心映射到传输控制协议（TCP）</td></tr><tr><td>RFC3082</td><td>服务定位协议（SLP）的预研报告</td></tr><tr><td>RFC3083</td><td>基线私人界面管理信息基础(MIB)用于兼容Cable Modems和Cable Modem 终端系统的DOCSIS</td></tr><tr><td>RFC3085</td><td>新闻型标记语言（NewsML）资源的URN名字空间</td></tr><tr><td>RFC3090</td><td>域名系统在区域状况下的安全扩展声明</td></tr><tr><td>RFC3091</td><td>改进数字产生协议</td></tr><tr><td>RFC3093</td><td>防火墙增进协议 (FEP)</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链路聚合</title>
    <link href="/2023/06/26/%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/"/>
    <url>/2023/06/26/%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="链路聚合"><a href="#链路聚合" class="headerlink" title="链路聚合"></a>链路聚合</h1><h2 id="什么是链路聚合？为什么要进行链路聚合？"><a href="#什么是链路聚合？为什么要进行链路聚合？" class="headerlink" title="什么是链路聚合？为什么要进行链路聚合？"></a>什么是链路聚合？为什么要进行链路聚合？</h2><p>链路聚合是一种网络技术，它将多个物理链路（如以太网、无线电连接或其他类型的连接）捆绑在一起形成一个逻辑链路，从而增加网络带宽和容错性。</p><p>在链路聚合中，多个物理链路被组合成一个逻辑链路，这个逻辑链路对于网络上的设备来说就像是一个单一的高带宽链路。这种技术可以帮助提高网络的吞吐量和可靠性，因为当一个物理链路出现故障时，其他链路可以继续正常工作，从而避免因单点故障而导致整个网络瘫痪。</p><p>链路聚合还可以使网络管理更加简单，因为网络管理员只需要管理一个逻辑链路，而不是多个物理链路。此外，链路聚合可以提高网络的负载均衡能力，因为它可以将网络流量分散到多个物理链路上，从而减轻单个链路的负载压力。</p><h2 id="Linux网卡bonding的7种模式"><a href="#Linux网卡bonding的7种模式" class="headerlink" title="Linux网卡bonding的7种模式"></a>Linux网卡bonding的7种模式</h2><p>bonding是linux内核自带的模块，它能将Linux系统的多个网卡绑定为一个逻辑端口，同时对外提供一个统一的IP地址，目前bonding模块的工作模式共有七种mode(0~6)。</p><h3 id="模式一：balance-rr-轮询均衡模式"><a href="#模式一：balance-rr-轮询均衡模式" class="headerlink" title="模式一：balance-rr 轮询均衡模式"></a>模式一：balance-rr 轮询均衡模式</h3><p>mode&#x3D;0 ，(balance-rr) Round-robin policy 轮询均衡模式</p><ul><li><p>所有链路处于负载均衡状态，轮循环方式（即依次传输：第1个包走eth0，下一个包就走eth1….一直循环下去，直到最后一个传输完毕）往每条链路发送报文，基于per packet方式发送。服务上ping 一个相同地址：1.1.1.1 双网卡的两个网卡都有流量发出。负载到两条链路上，说明是基于per packet方式 ，进行轮询发送。</p></li><li><p>这模式的特点是提供负载平衡（增加了带宽），同时支持容错能力，当有链路出问题，会把流量切换到正常的链路上。</p></li></ul><h3 id="模式二：active-backup-主备策略模式"><a href="#模式二：active-backup-主备策略模式" class="headerlink" title="模式二：active-backup 主备策略模式"></a>模式二：active-backup 主备策略模式</h3><p>mode&#x3D;1， (active-backup) Active-backup policy（主备策略模式）</p><ul><li>只有一个设备处于活动状态，当一个宕掉另一个马上由备份转换为主设备。mac地址是外部可见得，从外面看来，bond的MAC地址是唯一的，以避免switch(交换机)发生混乱。此模式只提供了容错能力；但是它的资源利用率较低，只有一个接口处于工作状态，资源利用率为1&#x2F;n。</li><li>这种模式接入不需要交换机端支持，随便怎么接入都行。</li></ul><h3 id="模式三：balance-xor-平衡策略"><a href="#模式三：balance-xor-平衡策略" class="headerlink" title="模式三：balance-xor 平衡策略"></a>模式三：balance-xor 平衡策略</h3><p>mode&#x3D;2,（balance-xor） XOR policy（根据hash的平衡策略）</p><ul><li>该模式将限定流量，以保证到达特定对端的流量总是从同一个接口上发出。既然目的地是通过MAC地址来决定的，因此该模式在“本地”网络配置下可以工作得很好。如果所有流量是通过单个路由器（比如 “网关”型网络配置，只有一个网关时，源和目标mac都固定了，那么这个算法算出的线路就一直是同一条，那么这种模式就没有多少意义了。），那该模式就不是最好的选择。和balance-rr一样，交换机端口需要能配置为“port channel”。这模式是通过源和目标mac做hash因子来做xor算法来选路的。此模式提供负载平衡和容错能力。</li><li>基于指定的传输HASH策略传输数据包。默认hash算法是： [(source MAC address XOR’d with destination MAC address) modulo slave count]。（XOR：异或），算法可以更改。</li></ul><h3 id="模式四：broadcast-广播策略"><a href="#模式四：broadcast-广播策略" class="headerlink" title="模式四：broadcast 广播策略"></a>模式四：broadcast 广播策略</h3><p>mode&#x3D;3，（broadcast）broadcast policy（广播策略）</p><ul><li>这种模式的特点是在每个slave接口上传输每个数据包，当有对端交换机失效，我们感觉不到任何downtime，但此法过于浪费资源;但是这种模式有很好的容错机制，适用于金融行业，因为他们需要高可靠性的网络，不允许出现任何问题。</li></ul><h3 id="模式五：802-3ad"><a href="#模式五：802-3ad" class="headerlink" title="模式五：802.3ad"></a>模式五：802.3ad</h3><p>mode&#x3D;4，（802.3ad）IEEE 802.3ad Dynamic link aggregation（IEEE 802.3ad 动态链接聚合）</p><ul><li>创建一个聚合组，它们共享同样的速率和双工设定。根据802.3ad规范将多个slave工作在同一个激活的聚合体下。外出流量的slave选择是基于传输hash策略，该策略可以通过<code>xmit_hash_policy</code>选项从缺省的XOR策略改变到其他策略。需要注意的 是，并不是所有的传输策略都是802.3ad适应的，尤其考虑到在802.3ad标准43.2.4章节提及的包乱序问题。不同的实现可能会有不同的适应性。</li><li>必要条件：<ul><li>条件1：ethtool支持获取每个slave的速率和双工设定</li><li>条件2：switch(交换机)支持IEEE802.3ad Dynamic link aggregation</li><li>条件3：大多数switch(交换机)需要经过特定配置才能支持802.3ad模式</li></ul></li></ul><h3 id="模式六：balance-tlb-适配器传输负载均衡"><a href="#模式六：balance-tlb-适配器传输负载均衡" class="headerlink" title="模式六：balance-tlb 适配器传输负载均衡"></a>模式六：balance-tlb 适配器传输负载均衡</h3><p>mode&#x3D;5，（balance-tlb）Adaptive transmit load balancing（适配器传输负载均衡）</p><ul><li>不需要任何特别的switch(交换机)支持的通道bonding。在每个slave上根据当前的负载（根据速度计算）分配外出流量。如果正在接受数据的slave出故障了，另一个slave接管失败的slave的MAC地址。</li><li>该模式的必要条件：ethtool支持获取每个slave的速率，mode6模式下无需配置交换机，因为做bonding的这两块网卡是使用不同的MAC地址。</li></ul><h3 id="模式七：balance-alb-适配器适应性负载均衡"><a href="#模式七：balance-alb-适配器适应性负载均衡" class="headerlink" title="模式七：balance-alb 适配器适应性负载均衡"></a>模式七：balance-alb 适配器适应性负载均衡</h3><p>mode&#x3D;6，（balance-alb）Adaptive load balancing（适配器适应性负载均衡）</p><ul><li><p>该模式包含了balance-tlb模式，同时加上针对IPV4流量的接收负载均衡（receiveload balance, rlb），而且不需要任何switch(交换机)的支持。交换机上也是可见多个网卡的MAC，不需要做链路聚合配置。</p></li><li><p>必要条件：</p><ul><li>条件1：ethtool支持获取每个slave的速率；</li><li>条件2：底层驱动支持设置某个设备的硬件地址，从而使得总是有个slave(curr_active_slave)使用bond的硬件地址，同时保证每个 bond 中的slave都有一个唯一的硬件地址。</li></ul></li></ul><h2 id="Linux配置Bonding模式"><a href="#Linux配置Bonding模式" class="headerlink" title="Linux配置Bonding模式"></a>Linux配置Bonding模式</h2><p><code>/etc/netplan/bond-config.yaml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">network:<br>  version: 2<br>  ethernets:<br>    ens4f0np0:<br>      addresses: []<br>      dhcp4: no<br>      optional: <span class="hljs-literal">true</span><br>    ens4f1np1:<br>      addresses: []<br>      dhcp4: no<br>      optional: <span class="hljs-literal">true</span><br>  bonds:<br>    bond0:<br>      interfaces:<br>        - ens4f0np0<br>        - ens4f1np1<br>      parameters:<br>        mode: 802.3ad<br>        mii-monitor-interval: 100<br>      addresses:<br>        - <span class="hljs-string">&quot;192.168.12.5/24&quot;</span><br>      gateway4: <span class="hljs-string">&quot;192.168.12.1&quot;</span><br></code></pre></td></tr></table></figure><h2 id="交换机链路聚合（Link-Aggregation，LA）"><a href="#交换机链路聚合（Link-Aggregation，LA）" class="headerlink" title="交换机链路聚合（Link Aggregation，LA）"></a>交换机链路聚合（Link Aggregation，LA）</h2><h3 id="Link-Aggregation"><a href="#Link-Aggregation" class="headerlink" title="Link Aggregation"></a><strong>Link Aggregation</strong></h3><p>不同厂商的交换机在端口聚合（Port Aggregation，PA）方面使用不同的术语。例如，Cisco使用EtherChannel，Brocade使用Brocade LAG，而IEEE 802.3ad LACP（Link Aggregation Control Protocol）则是一种基于标准的协议，它在2008年被转入IEEE 802.1ax标准中。LACP可以动态配置端口聚合，而且不依赖于任何特定的厂商，因此大多数以太网交换机都支持该协议。这些实现的目标都是一致的，即将两个或多个端口绑定在一起，作为一个高带宽的逻辑端口，以提高链路速度、冗余性、弹性和负载均衡性。</p><p>从技术上来说，我们可以在交换机之间使用多个端口创建并行的trunk链路，但生成树协议（STP）会将其视为环路，并关闭所有可能造成环路的链接。而端口聚合则生成一个单一的逻辑链路，不会导致环路问题，并可以作为Access Port（连接主机）或Trunk Port（承载多个VLAN流量）使用。</p><h3 id="Link-Aggregation-Control-Protocol-LACP"><a href="#Link-Aggregation-Control-Protocol-LACP" class="headerlink" title="Link Aggregation Control Protocol (LACP)"></a><strong>Link Aggregation Control Protocol (LACP)</strong></h3><p>LACP 是通过向所有启用LACP协议的链路发送LACPDU Frame来工作的，如果发现链路另一端的设备也启用了LACP，LACP将独自在同一条链路上发送Frame，使得两者能够发现它们之间的多条链路，并将它们合并成单条逻辑链路。</p><p>LACP的模式分为静态和动态，动态又分为主动和被动。</p><h4 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h4><p>mode on，手动强制模式：</p><p>不发送也不接收LACP协商报文，交换机物理端口被强制捆绑到etherchannel，数据包根据聚合口负载均衡模式在多个物理口上传输。一般默认的为基于包的负载均衡，即在多个网口之间轮询发送数据包。使用这种聚合模式时，对端也必须是mode on，强制形成etherchannel。</p><h4 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h4><ul><li>active，主动协商模式：</li></ul><p>交换机聚合口主动发出LACPDU报文，与对端符合802.3ad规范的动态聚合口主动协商。</p><p>一般推荐使用主动模式。</p><ul><li>passive，被动协商模式：</li></ul><p>交换机聚合口只接收LACPDU报文，被动与对端符合802.3ad规范的动态聚合口进行协商。</p><h2 id="Linux网卡bonding与交换机配置关系"><a href="#Linux网卡bonding与交换机配置关系" class="headerlink" title="Linux网卡bonding与交换机配置关系"></a>Linux网卡bonding与交换机配置关系</h2><table><thead><tr><th>bonding模式</th><th>交换机配置</th></tr></thead><tbody><tr><td>mode&#x3D;0，balance-rr 轮询均衡模式</td><td>LACP mode on 强行链路聚合</td></tr><tr><td>mode&#x3D;1，active-backup 主备模式</td><td>无特殊配置</td></tr><tr><td>mode&#x3D;2，balance&#x3D;xor，hash均衡模式</td><td>LACP mode on 强行链路聚合</td></tr><tr><td>mode&#x3D;3，broadcast 广播模式</td><td>LACP mode on 强行链路聚合</td></tr><tr><td>mode&#x3D;4，ieee802.3ad 动态链路聚合</td><td>LACP动态协商，建议主动模式</td></tr><tr><td>mode&#x3D;5，balance-tlb 适配器发送负载均衡</td><td>无特殊配置</td></tr><tr><td>mode&#x3D;6，balance-alb 适配器收发负载均衡</td><td>无特殊配置</td></tr></tbody></table><h2 id="Mellanox交换机配置链路聚合"><a href="#Mellanox交换机配置链路聚合" class="headerlink" title="Mellanox交换机配置链路聚合"></a>Mellanox交换机配置链路聚合</h2><p><img src="/image/%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88/image-20230627190550381.png" alt="image-20230627190550381"></p><center>链路聚合连接示意图</center><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#登陆</span><br><span class="hljs-built_in">enable</span><br>config t<br><br>interface port-channel 1<br><span class="hljs-built_in">exit</span><br>lacp<br><br>interface ethernet 1/8<br>channel-group 1 mode active<br><span class="hljs-built_in">exit</span><br><br>interface ethernet 1/7<br>channel-group 1 mode active<br><span class="hljs-built_in">exit</span><br><br>interface port-channel 2<br><span class="hljs-built_in">exit</span><br>lacp<br><br>interface ethernet 1/1<br>channel-group 2 mode active<br><span class="hljs-built_in">exit</span><br>interface ethernet 1/2<br>channel-group 2 mode active<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.nvidia.com/networking/pages/viewpage.action?pageId=19812499">Link Aggregation Group (LAG) - Onyx v3.8.2110 - NVIDIA Networking Docs</a> Mellanox交换机链路聚合配置方式。</p><p><a href="https://docs.nvidia.com/networking/m/view-rendered-page.action?abstractPageId=19812159">BlueField Link Aggregation - NVIDIA Networking Docs — BlueField Link Aggregation - NVIDIA Networking Docs</a> Mellanox网卡链路聚合配置方式。</p><p><a href="https://enterprise-support.nvidia.com/s/article/howto-configure-lacp-on-mellanox-switches">HowTo Configure LACP on Mellanox Switches (nvidia.com)</a> Mellanox交换机链路聚合配置示例。</p><p><a href="https://www.cnblogs.com/sammyliu/articles/4894991.html">以太网链路聚合控制协议（LACP）（链路聚合控制协议：将多个端口虚机成一个逻辑端口来提高链路速度， Active&#x2F;Active 模式） - SammyLiu - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/syuee/p/14604221.html">linux网卡聚合及链路聚合 - 白色的番茄 - 博客园 (cnblogs.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/115163338">交换机链路聚合与Linux的bond模式对照 - 知乎 (zhihu.com)</a></p><p><a href="http://infohpc.com/Labs/shownews.php?id=17">NVIDIA Mellanox 交换机 Onyx 配置 L2 MLAG，基础案例-赛诺信致软件技术（北京）有限公司 (infohpc.com)</a></p><p><a href="https://www.cnblogs.com/sxycloud/p/14840994.html">交换机链路聚合模式说明 - sxy-cloud - 博客园 (cnblogs.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/137959501">交换技术链路聚合配置 - 知乎 (zhihu.com)</a></p><p><a href="https://support.huawei.com/enterprise/zh/knowledge/EKB1001172264">Linux下双网卡绑定七种模式 多网卡的7种bond模式原理- 华为 (huawei.com)</a></p><p><a href="https://blog.csdn.net/qq_43284344/article/details/84309446">linux—高级网络配置：链路聚合_liunx做链路聚合命令_一只胖橘猫的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>链路聚合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LACP</tag>
      
      <tag>链路聚合</tag>
      
      <tag>LA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LAG vs LACP:有什么区别？</title>
    <link href="/2023/06/26/LAG%20vs%20LACP%EF%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <url>/2023/06/26/LAG%20vs%20LACP%EF%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="LAG-vs-LACP：有什么区别？"><a href="#LAG-vs-LACP：有什么区别？" class="headerlink" title="LAG vs LACP：有什么区别？"></a><strong>LAG vs LACP：有什么区别？</strong></h1><p>在以太网交换机连接领域，链路聚合是一种在不同网络交换机之间并行组合多个端口的技术。它的功能是经济高效地扩展带宽，并在链路故障时提供冗余。但是，总称“链路聚合”是一个相当宽泛的术语，包含各种概念：链路聚合控制协议，链路聚合组，MLAG，802.3ad，802.1AX等。其中，LAG与LACP的问题使许多人感到困惑。在这里，我们按顺序介绍LAG与LACP，并比较LAG与LACP，以说明它们的关系和差异。</p><p><img src="/image/LAG%20vs%20LACP%EF%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/LAG-vs-LACP-What-is-the-Difference.jpg" alt="img"></p><h2 id="LAG-vs-LACP：什么是-LAG？"><a href="#LAG-vs-LACP：什么是-LAG？" class="headerlink" title="LAG vs LACP：什么是 LAG？"></a><strong>LAG vs LACP：什么是 LAG？</strong></h2><p><strong>LAG（链路聚合组）</strong>是链路聚合的实际技术或实例。当我们在两个交换机之间并行连接多个端口并将它们配置为 LAG 时，就会形成链路聚合组。因此，LAG在两个交换机之间建立了多个链路，从而扩展了带宽。此外，它还在网络故障和负载平衡流量中提供链路级冗余。即使一条链路发生故障，两台交换机之间的其余链路仍将运行。它们还会接管那些应该通过故障流量遍历的流量，因此数据包不会丢失。</p><h2 id="LAG-vs-LACP：什么是-LACP？"><a href="#LAG-vs-LACP：什么是-LACP？" class="headerlink" title="LAG vs LACP：什么是 LACP？"></a><strong>LAG vs LACP：什么是 LACP？</strong></h2><p><strong>LACP（链路聚合控制协议）</strong>是一种自动设置 LAG 的控制协议。因此，您可以选择在没有 LACP 的情况下构建静态 LAG。或者，您可以选择使用 LACP 设置动态 LAG。简单地说，LACP 不是一个链路聚合实例，而是一个用于定义它的协议。LACP 使 LAG 能够从静态 LAG 传输到动态 LAG，从而允许 LAG 组件网络交换机之间的链路聚合信息交换。信息在链路聚合控制协议数据单元 （LACPDU） 中作为数据包传递。两个交换机上的每个端口都可以通过控制协议配置为主动或被动，以优先传输 LACPDU。</p><h2 id="LAG实施方案"><a href="#LAG实施方案" class="headerlink" title="LAG实施方案"></a>LAG实施方案</h2><p>由于 LACP 只是链路聚合组的协议。我们将省略 LAG 与 LACP 的区别，以 FS.COM 查看 LAG 实施方案。 以两台千兆 PoE 网络交换机和另一台 10GbE 光纤交换机之间的 LAG 为例。只需用一根电缆连接每个千兆 PoE 交换机上的一个端口，我们就可以获得 1GE 带宽。但是，当您双链路、三链路或更高的倍数时，带宽将变为 2GE、3GE 等。</p><p>此外，为了上行链路骨干核心交换机，我们可以使用 4 根带有相应模块的光纤跳线来链接 48 端口千兆 PoE 交换机 10GE SFP+ 端口和 10GbE 光纤交换机。然后，S1600-48T4S 上的上行链路带宽扩展到 40GE。在 48 端口 PoE 交换机上形成两个 LAG。形成 LAG 的链路上限和两个交换机之间的 LAG 数量因供应商和交换机型号而异。</p><p><img src="/image/LAG%20vs%20LACP%EF%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/LAG-vs-LACP-link-aggregation-implement-scenario-by-fs-PoE-switch-and-fiber-switch.jpg" alt="img"></p><p>图 1：在 FS 48 端口 PoE 交换机和 24 端口 PoE 交换机上并行链接 4 个 1GE 端口以设置 LAG，从而将带宽从 1000Mbps 提高到 4 × 1000Mbps。在此照片中，已在 FS 48 端口 PoE 交换机上实施了两个 LAG。</p><h2 id="LAG-vs-LACP：扩展带宽的链路聚合优势"><a href="#LAG-vs-LACP：扩展带宽的链路聚合优势" class="headerlink" title="LAG vs LACP：扩展带宽的链路聚合优势"></a><strong>LAG vs LACP：扩展带宽的链路聚合优势</strong></h2><p>无论 LAG 是否部署链路聚合控制协议，都不需要昂贵的硬件升级。因此，链路聚合组为带宽扩展提供了经济高效的解决方案。堆叠开关确实是获得更高带宽的高级方法。但是，它仅限于可堆叠交换机，不支持单独放置。购买像10GbE交换机这样的更高速度的交换机也是一种直接有效的解决方案。但对于普通用户来说，这种硬件升级超出了预算。</p><h2 id="LAG-vs-LACP：有什么区别？-1"><a href="#LAG-vs-LACP：有什么区别？-1" class="headerlink" title="LAG vs LACP：有什么区别？"></a><strong>LAG vs LACP：有什么区别？</strong></h2><ul><li><p>链路聚合组是链路聚合的实际实例，而 LACP 是用于自动配置和维护 LAG 的协议。</p></li><li><p>不带链路聚合控制协议的 LAG 是一种静态配置，其中 LAG 中的每对端口都需要分别进行手动配置。但是，启用 LACP 的端口是动态配置，可以在构建 LAG 时自动配置为中继组。</p></li><li><p>当谈论 LAG 与 LACP 时，通常指的是没有 LACP 的静态 LAG 与带有 LACP 的动态 LAG。一般来说，动态LAG配置在自动故障转移和相互动态配置方面比静态LAG配置具有优势。在静态链路聚合中，LAG无法分离配置或布线错误，从而导致不必要的网络故障。</p></li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>LAG与LACP问题是为了解决它们之间的混淆概念。LAG 是链路聚合的实际实例。LACP 是一种控制协议，用于使 LAG 能够自动配置网络交换机端口、分离链路故障和激活故障转移。因此，LAG 包含静态 LAG 配置和动态 LAG 配置，具体取决于是否使用可选的链路聚合控制协议。总体而言，链路聚合组是一种通过交换机堆叠和其他硬件升级方法扩展带宽的经济高效方法。为了最大限度地减少网络链路故障，在静态 LAG 上启用 LACP 的动态 LAG 配置是一个更好的解决方案。</p><blockquote><p>原文地址：<a href="https://www.fiber-optic-components.com/llag-vs-lacp-relationship-difference.html">LAG vs LACP: What’s the Relationship and Difference?Fiber Optic Components (fiber-optic-components.com)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>链路聚合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LAG</tag>
      
      <tag>LACP</tag>
      
      <tag>链路聚合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows Terminal添加至鼠标右键</title>
    <link href="/2023/06/19/Windows%20Terminal%E6%B7%BB%E5%8A%A0%E8%87%B3%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE/"/>
    <url>/2023/06/19/Windows%20Terminal%E6%B7%BB%E5%8A%A0%E8%87%B3%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows-Terminal添加至鼠标右键"><a href="#Windows-Terminal添加至鼠标右键" class="headerlink" title="Windows Terminal添加至鼠标右键"></a>Windows Terminal添加至鼠标右键</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在<code>Microsoft Store</code>中即可下载。</p><p><img src="/image/Windows%20Terminal%E6%B7%BB%E5%8A%A0%E8%87%B3%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE/image-20230619110413661.png" alt="image-20230619110413661"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="在鼠标右键打开"><a href="#在鼠标右键打开" class="headerlink" title="在鼠标右键打开"></a>在鼠标右键打开</h3><h4 id="下载Terminal图标"><a href="#下载Terminal图标" class="headerlink" title="下载Terminal图标"></a>下载Terminal图标</h4><p>图标地址:<a href="https://raw.githubusercontent.com/microsoft/terminal/master/res/terminal.ico">https://raw.githubusercontent.com/microsoft/terminal/master/res/terminal.ico</a></p><p>下载后保存在某个文件夹<code>path</code></p><h4 id="添加到鼠标右键"><a href="#添加到鼠标右键" class="headerlink" title="添加到鼠标右键"></a>添加到鼠标右键</h4><h5 id="批处理修改注册表"><a href="#批处理修改注册表" class="headerlink" title="批处理修改注册表"></a>批处理修改注册表</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br>reg.exe add <span class="hljs-string">&quot;HKEY_CLASSES_ROOT\Directory\Background\shell\wt&quot;</span> /f /ve /d <span class="hljs-string">&quot;Windows Terminal here&quot;</span><br>reg.exe add <span class="hljs-string">&quot;HKEY_CLASSES_ROOT\Directory\Background\shell\wt&quot;</span> /f /v <span class="hljs-string">&quot;Icon&quot;</span> /t REG_EXPAND_SZ /d <span class="hljs-string">&quot;path\terminal.ico&quot;</span><br>reg.exe add <span class="hljs-string">&quot;HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command&quot;</span> /f /ve /t REG_EXPAND_SZ /d <span class="hljs-string">&quot;\&quot;%%LOCALAPPDATA%%\Microsoft\WindowsApps\wt.exe\&quot;&quot;</span><br>pause<br></code></pre></td></tr></table></figure><h5 id="手动修改注册表"><a href="#手动修改注册表" class="headerlink" title="手动修改注册表"></a>手动修改注册表</h5><p>按下Win+R快捷键打开运行,然后输入<code>regedit</code>打开<strong>注册表编辑器</strong>,然后在地址栏中输入:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">计算机\HKEY_CLASSES_ROOT\directory\background\shell<br></code></pre></td></tr></table></figure><p><img src="/image/Windows%20Terminal%E6%B7%BB%E5%8A%A0%E8%87%B3%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE/image-20230619111056009.png" alt="image-20230619111056009"></p><p>新建<strong>项</strong>:<code>wt</code></p><p><strong>点击</strong>wt，<strong>双击</strong>右边的<strong>默认</strong>，在里面输入鼠标右键选项的名称：<code>Windows Terminal here</code></p><p>右键wt，选择新建字符串，名为为<code>Icon</code>，在里面输入下载好的图标的地址：<code>path\terminal.ico</code></p><p>右键wt，选择新建项,输入command</p><p>然后点击command,双击右边的默认,输入Terminal的地址<code>&quot;%%LOCALAPPDATA%%\Microsoft\WindowsApps\wt.exe\&quot;</code>即可。</p><p><img src="/image/Windows%20Terminal%E6%B7%BB%E5%8A%A0%E8%87%B3%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE/image-20230619111734537.png" alt="image-20230619111734537"></p><h4 id="在当前目录打开"><a href="#在当前目录打开" class="headerlink" title="在当前目录打开"></a>在当前目录打开</h4><h5 id="打开配置文件"><a href="#打开配置文件" class="headerlink" title="打开配置文件"></a>打开配置文件</h5><p>点击Windows Terminal菜单栏上的<strong>下拉箭头</strong>,然后选择Settings:</p><p><img src="/image/Windows%20Terminal%E6%B7%BB%E5%8A%A0%E8%87%B3%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE/image-20230619110508615.png" alt="image-20230619110508615"></p><p><img src="/image/Windows%20Terminal%E6%B7%BB%E5%8A%A0%E8%87%B3%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE/image-20230619112038125.png" alt="image-20230619112038125"></p><h5 id="在当前目录打开-1"><a href="#在当前目录打开-1" class="headerlink" title="在当前目录打开"></a>在当前目录打开</h5><p>在默认打开的终端配置中添加<code>&quot;startingDirectory&quot; : &quot;.&quot;,</code>这个配置即可:</p><p><img src="/image/Windows%20Terminal%E6%B7%BB%E5%8A%A0%E8%87%B3%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE/image-20230619112140525.png" alt="image-20230619112140525"></p>]]></content>
    
    
    <categories>
      
      <category>Windows Terminal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows Terminal</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译安装调试Linux内核</title>
    <link href="/2023/06/13/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%B0%83%E8%AF%95Linux%E5%86%85%E6%A0%B8/"/>
    <url>/2023/06/13/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%B0%83%E8%AF%95Linux%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="编译安装内核"><a href="#编译安装内核" class="headerlink" title="编译安装内核"></a>编译安装内核</h1><h2 id="下载内核"><a href="#下载内核" class="headerlink" title="下载内核"></a>下载内核</h2><p>Linux内核下载<a href="https://www.kernel.org/">The Linux Kernel Archives</a></p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install gcc g++ libncurses5-dev build-essential kernel-package libssl-dev libc6-dev bin86 flex bison qttools5-dev libelf-dev<br></code></pre></td></tr></table></figure><h2 id="更改-config"><a href="#更改-config" class="headerlink" title="更改.config"></a>更改.config</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#拷贝现有ubuntu的.config至编译内核的目录</span><br><span class="hljs-built_in">cp</span> -v /boot/config-$(<span class="hljs-built_in">uname</span> -r) .config<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make menuconfig<br></code></pre></td></tr></table></figure><ol><li>打开<code>.config</code>更改<code>CONFIG_SYSTEM_TRUSTED_KEYS </code>和<code>CONFIG_SYSTEM_REVOCATION_KEYS</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">CONFIG_SYSTEM_TRUSTED_KEYS=<span class="hljs-string">&#x27;&#x27;</span><br>CONFIG_SYSTEM_EXTRA_CERTIFICATE_SIZE=2048<br>CONFIG_SYSTEM_REVOCATION_KEYS=<span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>更改<code>CONFIG_DEBUG_INFO_BTF</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">CONFIG_DEBUG_INFO_BTF=n<br></code></pre></td></tr></table></figure><ol start="3"><li>注释掉CONFIG_X86_X32</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#CONFIG_X86_X32=y</span><br></code></pre></td></tr></table></figure><h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#基于文本选单的配置界面，字符终端下推荐使用</span><br>make menuconfig<br><br>make -j$(<span class="hljs-built_in">nproc</span>)<br><br>make all<br><br><span class="hljs-comment"># 编译模块</span><br>make -j$(<span class="hljs-built_in">nproc</span>) modules<br></code></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="首先安装模块"><a href="#首先安装模块" class="headerlink" title="首先安装模块"></a>首先安装模块</h3><p>这里加上<code>INSTALL_MOD_STRIP=1</code>是为了避免内核启动时卡在 <a href="#ramdisk">loading initial ramdisk</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo make INSTALL_MOD_STRIP=1 modules_install<br></code></pre></td></tr></table></figure><h3 id="安装内核"><a href="#安装内核" class="headerlink" title="安装内核"></a>安装内核</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make bzImage<br>sudo make install<br></code></pre></td></tr></table></figure><h3 id="更改引导"><a href="#更改引导" class="headerlink" title="更改引导"></a>更改引导</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-initramfs -c -k 5.10.0<br></code></pre></td></tr></table></figure><h3 id="更改grub"><a href="#更改grub" class="headerlink" title="更改grub"></a>更改<code>grub</code></h3><p>修改文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vi /etc/default/grub<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#GRUB_TIMEOUT_STYLE=hidden</span><br>GRUB_TIMEOUT=10<br></code></pre></td></tr></table></figure><p>更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-grub<br></code></pre></td></tr></table></figure><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">reboot<br></code></pre></td></tr></table></figure><p>在<code>GRUB</code>页面选择<code>Advanced options for Ubuntu</code></p><p><img src="/image/Linux%E5%86%85%E6%A0%B8/image-20230515104210488.png" alt="image-20230515104210488"></p><p>选择需要启动的内核版本</p><p><img src="/image/Linux%E5%86%85%E6%A0%B8/image-20230517111217516.png" alt="image-20230517111217516"></p><p><img src="/image/Linux%E5%86%85%E6%A0%B8/image-20230515101713706.png" alt="image-20230517111217516"></p><center>安装新内核之前的内核版本</center><p><img src="/image/Linux%E5%86%85%E6%A0%B8/image-20230517110513053.png" alt="image-20230517110513053"></p><center>安装新内核之后</center><p><a href="#GRUB">若重启未看到选择内核的页面参考</a></p><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="清理内核源目录"><a href="#清理内核源目录" class="headerlink" title="清理内核源目录"></a>清理内核源目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># make mrproper会删除配置的.config以及其他备份</span><br>sudo make mrproper<br><span class="hljs-comment"># make clean会删除编译过程中生成的中间文件和内核镜像文件</span><br>sudo make clean<br></code></pre></td></tr></table></figure><h3 id="卸载安装的内核"><a href="#卸载安装的内核" class="headerlink" title="卸载安装的内核"></a>卸载安装的内核</h3><p>获取所有安装的内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg --get-selections | grep linux<br></code></pre></td></tr></table></figure><p>选择要卸载的版本，卸载下列安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt remove linux-image-&lt;版本&gt;-generic<br>sudo apt remove linux-headers-&lt;版本&gt;<br>sudo apt remove linux-headers-&lt;版本&gt;-generic<br>sudo apt remove linux-modules-&lt;版本&gt;-generic<br></code></pre></td></tr></table></figure><p>卸载源码版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">rm</span> /boot/vmlinuz-5.10.0<br>sudo <span class="hljs-built_in">rm</span> /boot/initrd.img-5.10.0<br>sudo <span class="hljs-built_in">rm</span> /boot/System.map-5.10.0<br>sudo <span class="hljs-built_in">rm</span> /boot/config-5.10.0<br>sudo <span class="hljs-built_in">rm</span> -rf /lib/modules/5.10.0<br></code></pre></td></tr></table></figure><p>更新启动引导</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-grub<br></code></pre></td></tr></table></figure><h3 id="修改内核配置菜单实现对新加入内核源码的控制"><a href="#修改内核配置菜单实现对新加入内核源码的控制" class="headerlink" title="修改内核配置菜单实现对新加入内核源码的控制"></a>修改内核配置菜单实现对新加入内核源码的控制</h3><ol><li><p>将源码拷贝到内核对应的文件夹下</p></li><li><p>为配置界面添加控制新加入源代码的内容</p><p> 在加入源码的目录下创建<code>Kconfig</code>文件，便添加相应控制内容</p></li><li><p>修改上层<code>Kconfig</code>文件，包含新加入源码的<code>Kconfig</code>文件。</p></li><li><p>修改<code>Makefile</code>文件</p></li><li><p>修改上一级目录的Makefile</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make[1]: *** No rule to make target <span class="hljs-string">&#x27;debian/canonical-certs.pem&#x27;</span>, needed by <span class="hljs-string">&#x27;certs/x509_certificate_list&#x27;</span>.  Stop.<br>make: *** [Makefile:1868: certs] Error 2<br></code></pre></td></tr></table></figure><p>解决方法<a href="https://www.youtube.com/watch?v=7G3UkugVhOw">(104) how to fix the error “No rule to make target ‘debian canonical certs pem’, needed by ‘certs x509 cer - YouTube</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano .config<br>查找到debian/canonical-certs.pem和debian/canonical-revoked-certs.pem字符串删除<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">BTF: .tmp_vmlinux.btf: pahole (pahole) is not available<br></code></pre></td></tr></table></figure><p>解决方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install dwarves<br></code></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="1-Module-symvers-is-missing"><a href="#1-Module-symvers-is-missing" class="headerlink" title="1. Module.symvers is missing"></a>1. Module.symvers is missing</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">WARNING: Symbol version dump <span class="hljs-string">&quot;Module.symvers&quot;</span> is missing.<br>         Modules may not have dependencies or modversions.<br>         You may get many unresolved symbol warnings.<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make modules_prepare<br></code></pre></td></tr></table></figure><h3 id="2-No-rule-to-make-target-‘debian-x2F-canonical-certs-pem‘-needed-by-‘certs-x2F-x509-certificate-list‘"><a href="#2-No-rule-to-make-target-‘debian-x2F-canonical-certs-pem‘-needed-by-‘certs-x2F-x509-certificate-list‘" class="headerlink" title="2. No rule to make target ‘debian&#x2F;canonical-certs.pem‘, needed by ‘certs&#x2F;x509_certificate_list‘"></a>2. No rule to make target ‘debian&#x2F;canonical-certs.pem‘, needed by ‘certs&#x2F;x509_certificate_list‘</h3><p>可以修改config：</p><p>vim .config</p><p>修改<code>CONFIG_SYSTEM_TRUSTED_KEYS</code>，将其置空： CONFIG_SYSTEM_TRUSTED_KEYS&#x3D;””<em>也可能需要设置</em>CONFIG_SYSTEM_REVOCATION_KEYS为空。</p><h3 id="3-FAILED-load-BTF-from-vmlinux-No-such-file-or-directory"><a href="#3-FAILED-load-BTF-from-vmlinux-No-such-file-or-directory" class="headerlink" title="3. FAILED:load BTF from vmlinux:No such file or directory"></a>3. FAILED:load BTF from vmlinux:No such file or directory</h3><p>vim .config</p><p>修改<code>CONFIG_DEBUG_INFO_BTF</code>，将其置n</p><h3 id="4-安装完内核之后无法显示GRUB用以选择内核启动"><a href="#4-安装完内核之后无法显示GRUB用以选择内核启动" class="headerlink" title="4. 安装完内核之后无法显示GRUB用以选择内核启动"></a>4. 安装完内核之后无法显示<code>GRUB</code>用以选择内核启动<a name="GRUB"/></h3><p>进入命令行之后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vi /etc/default/grub<br></code></pre></td></tr></table></figure><p>注释掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># GRUB_TIMEOUT_STYLE=hidden</span><br></code></pre></td></tr></table></figure><p>修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">GRUB_TIMEOUT=10<br><br>GRUB_COMLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;text&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/image/Linux%E5%86%85%E6%A0%B8/image-20230515103459264.png" alt="image-20230515103459264"></p><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-grub<br></code></pre></td></tr></table></figure><p><img src="/image/Linux%E5%86%85%E6%A0%B8/image-20230515103559801.png" alt="image-20230515103559801"></p><h3 id="5-内核启动卡在loading-initial-ramdisk"><a href="#5-内核启动卡在loading-initial-ramdisk" class="headerlink" title="5. 内核启动卡在loading initial ramdisk"></a>5. 内核启动卡在<code>loading initial ramdisk</code><a name="ramdisk"/></h3><p>编译内核过程中，当安装内核模块时未使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">INSTALL_MOD_STRIP=1<br></code></pre></td></tr></table></figure><p>标注，会导致<code>initrd</code>文件过大，Ubuntu 20.04所用的Grub 2.04无法支持过大的initrd文件（如500M），导致内核启动时卡在<code>“loading initial ramdisk”（Can’t allocate initrd）</code>。</p><p>可行的办法：</p><p>安装模块时加上<code>INSTALL_MOD_STRIP=1</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo make INSTALL_MOD_STRIP=1 modules_install<br></code></pre></td></tr></table></figure><h3 id="6-sign-file-No-such-file-or-directory"><a href="#6-sign-file-No-such-file-or-directory" class="headerlink" title="6. sign-file: : No such file or directory"></a>6. sign-file: : No such file or directory</h3><p>报错信息：</p><p><img src="/image/Linux%E5%86%85%E6%A0%B8/image-20230516082845572.png" alt="image-20230516082845572"></p><p>解决方法：</p><p> 将<code>.config</code>的 <code>CONFIG_MODULE_SIG_KEY=&quot;cert/signing_key.pem&quot;</code>恢复后解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">CONFIG_MODULE_SIG_KEY=<span class="hljs-string">&quot;cert/signing_key.pem&quot;</span><br></code></pre></td></tr></table></figure><h3 id="7-zstd-not-found"><a href="#7-zstd-not-found" class="headerlink" title="7. zstd: not found"></a>7. zstd: not found</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ZSTD22  <span class="hljs-built_in">arch</span>/x86/boot/compressed/vmlinux.bin.zst<br>/bin/sh: 1: zstd: not found<br>make[2]: *** [<span class="hljs-built_in">arch</span>/x86/boot/compressed/Makefile:134：<span class="hljs-built_in">arch</span>/x86/boot/compressed/vmlinux.bin.zst] 错误 127<br>make[2]: *** 正在删除文件“<span class="hljs-built_in">arch</span>/x86/boot/compressed/vmlinux.bin.zst” make[1]: *** [<span class="hljs-built_in">arch</span>/x86/boot/Makefile:115：<span class="hljs-built_in">arch</span>/x86/boot/compressed/vmlinux] 错误 2<br></code></pre></td></tr></table></figure><p>解决方法</p><p>在配置内核时更改<code>Kernel compression mode</code>为<code>LZMA</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">General setup  ---&gt;<br>Kernel compression mode (LZMA)  ---&gt;<br></code></pre></td></tr></table></figure><p>保存后重新编译安装即可。</p><h2 id="单独编译Linux内核的某一个模块"><a href="#单独编译Linux内核的某一个模块" class="headerlink" title="单独编译Linux内核的某一个模块"></a>单独编译Linux内核的某一个模块</h2><p>找到对应的模块文件夹，找到需要编译的文件，确认编译的config文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make CONFIG_INFINIBAND=m -C &lt;源码&gt; M=&lt;模块文件夹&gt; modules<br></code></pre></td></tr></table></figure><h1 id="qemu-gdb调试linux内核"><a href="#qemu-gdb调试linux内核" class="headerlink" title="qemu+gdb调试linux内核"></a>qemu+gdb调试linux内核</h1><h2 id="安装qemu"><a href="#安装qemu" class="headerlink" title="安装qemu"></a>安装qemu</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install qemu<br></code></pre></td></tr></table></figure><h2 id="配置调试版内核"><a href="#配置调试版内核" class="headerlink" title="配置调试版内核"></a>配置调试版内核</h2><p>对内核进行调试需要解析符号信息，所以得编译一个调试版内核。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> linux-5.15<br>make menuconfig<br></code></pre></td></tr></table></figure><p>这里需要开启内核参数<code>CONFIG_DEBUG_INFO</code>和<code>CONFIG_GDB_SCRIPTS</code>。GDB提供了Python接口来扩展功能，内核基于Python接口实现了一系列辅助脚本，简化内核调试，开启<code>CONFIG_GDB_SCRIPTS</code>参数就可以使用了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">Kernel hacking  ---&gt;<br>    [*] Kernel debugging<br>    Compile-time checks and compiler options  ---&gt;<br>        [*] Compile the kernel with debug info<br>        [*]   Provide GDB scripts <span class="hljs-keyword">for</span> kernel debugging<br></code></pre></td></tr></table></figure><h2 id="构建initramfs根文件系统"><a href="#构建initramfs根文件系统" class="headerlink" title="构建initramfs根文件系统"></a>构建initramfs根文件系统</h2><p>Linux系统启动阶段，boot loader加载完内核文件vmlinuz后，内核紧接着需要挂载磁盘根文件系统，但如果此时内核没有相应驱动，无法识别磁盘，就需要先加载驱动，而驱动又位于<code>/lib/modules</code>，得挂载根文件系统才能读取，这就陷入了一个两难境地，系统无法顺利启动。于是有了initramfs根文件系统，其中包含必要的设备驱动和工具，boot loader加载initramfs到内存中，内核会将其挂载到根目录<code>/</code>,然后运行<code>/init</code>脚本，挂载真正的磁盘根文件系统。</p><p>这里借助<a href="https://www.busybox.net/">BusyBox</a>构建极简initramfs，提供基本的用户态可执行程序。</p><p>编译BusyBox，配置<code>CONFIG_STATIC</code>参数，编译静态版BusyBox，编译好的可执行文件<code>busybox</code>不依赖动态链接库，可以独立运行，方便构建initramfs。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> busybox-1.28.0<br>make menuconfig<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Settings  ---&gt;<br>    [*] Build static binary (no shared libs)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j 20<br>make install<br></code></pre></td></tr></table></figure><p>会安装在<code>_install</code>目录:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> _install<br>bin  linuxrc  sbin  usr<br></code></pre></td></tr></table></figure><p>创建initramfs，其中包含BusyBox可执行程序、必要的设备文件、启动脚本<code>init</code>。这里没有内核模块，如果需要调试内核模块，可将需要的内核模块包含进来。<code>init</code>脚本只挂载了虚拟文件系统<code>procfs</code>和<code>sysfs</code>，没有挂载磁盘根文件系统，所有调试操作都在内存中进行，不会落磁盘。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> initramfs<br><span class="hljs-built_in">cd</span> initramfs<br><span class="hljs-built_in">cp</span> ../_install/* -rf ./<br><span class="hljs-built_in">mkdir</span> dev proc sys<br>sudo <span class="hljs-built_in">cp</span> -a /dev/&#123;null, console, <span class="hljs-built_in">tty</span>, tty1, tty2, tty3, tty4&#125; ./dev/<br><span class="hljs-built_in">rm</span> linuxrc<br>vim init<br><span class="hljs-built_in">chmod</span> a+x init<br><span class="hljs-built_in">ls</span><br>bin   dev  init  proc  sbin  sys   usr<br></code></pre></td></tr></table></figure><p>init文件的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>mount -t proc none /proc<br>mount -t sysfs none /sys<br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\nBoot took <span class="hljs-subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span><br><span class="hljs-built_in">exec</span> /bin/sh<br></code></pre></td></tr></table></figure><p>打包initramfs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../initramfs.cpio.gz<br></code></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> busybox-xxx<br>qemu-system-x86_64 -s -kernel /path/to/vmlinux -initrd initramfs.cpio.gz -nographic -append <span class="hljs-string">&quot;console=ttyS0&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>-s</code> 是<code>-gdb tcp::1234</code>的缩写，监听1234端口，在GDB中通过<code>target remote localhost:1234</code>连接；</li><li><code>-kernel</code> 指定编译好的调试内核<code>vmlinux</code>路径；</li><li><code>initrd</code> 指定制作好的<code>initramfs</code>；</li><li><code>-nographic</code>取消图形输出窗口，试qemu成简单的命令行程序。</li><li><code>-append &quot;console=ttyS0&quot;</code>将输出重定向到console，将会显示在标准输出stdio。</li></ul><p>启动后的根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/ <span class="hljs-built_in">ls</span><br>bin   dev  init  proc  root  sbin  sys   usr<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://consen.github.io/2018/01/17/debug-linux-kernel-with-qemu-and-gdb/">使用QEMU和GDB调试Linux内核 | Consen</a></p><p><a href="https://www.cnblogs.com/dream397/p/13984263.html">Linux下使用内核源码单独编译某一模块 - tycoon3 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/phmatthaus/article/details/124353775">内核错误: No rule to make target ‘debian&#x2F;canonical-certs.pem‘, needed by ‘certs&#x2F;x509_certificate_list‘_no rule to make target ‘debian&#x2F;canonical-certs.pem_蓝天居士的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/yaoxinJJJ/article/details/115433638">Linux 内核 下载 编译 安装 2021 ubuntu_yaoxinJJJ的博客-CSDN博客</a></p><p><a href="https://www.zhaixue.cc/kernel/kernel-module_sysmvers.html">内核Module.symvers文件揭秘 - Linux内核编程 | 宅学部落 (zhaixue.cc)</a></p><p><a href="https://www.cnblogs.com/harrypotterjackson/p/11846222.html">如何编译安装Linux内核 - LightningStar - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/gmpy/p/12533548.html">ubuntu上更新和卸载Linux内核 - 广漠飘羽 - 博客园 (cnblogs.com)</a></p><p><a href="https://github.com/chiwent/blog/issues/1">关于Ubuntu内核(更新和卸载内核、取消自动更新) · Issue #1 · chiwent&#x2F;blog (github.com)</a></p><p><a href="https://blog.csdn.net/HandsomeHong/article/details/125157372">自行编译内核，启动内核卡在“loading initial ramdisk”_启动卡在initrd_奇妙之二进制的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/bdwdwks/article/details/106294349">linux——编译内核（ubuntu18.04+linux-5.6.4）</a></p><p><a href="https://blog.csdn.net/weixin_52592969/article/details/127815302">编译内核 make modules_install报错SSL error:02001002:system library:fopen:No such file or directory_ssl: error:02001002_酱山楂的博客-CSDN博客</a></p><p><a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/index.html">中文翻译 — The Linux Kernel documentation</a> Linux内核中文文档。</p><p><a href="https://blog.csdn.net/sustwct/article/details/7109251">[arch&#x2F;x86&#x2F;boot&#x2F;compressed&#x2F;vmlinux.bin.lzma] Error 1_sustwct的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PetaLinux常用操作</title>
    <link href="/2023/06/12/PetaLinux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/06/12/PetaLinux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="安装petalinux2022-2"><a href="#安装petalinux2022-2" class="headerlink" title="安装petalinux2022.2"></a>安装petalinux2022.2</h1><ol><li>安装依赖包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install iproute2 gawk python3 python build-essential gcc git make net-tools libncurses5-dev tftpd zlib1g-dev libssl-dev flex bison libselinux1 gnupg wget git-core diffstat chrpath socat xterm autoconf libtool tar unzip texinfo zlib1g-dev gcc-multilib automake zlib1g:i386 screen pax gzip cpio python3-pip python3-pexpect xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint3 libtinfo5<br></code></pre></td></tr></table></figure><ol start="2"><li>更改文件夹权限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> petalinux2022.2<br>sudo <span class="hljs-built_in">chmod</span> 777 petalinux2022 ./<br></code></pre></td></tr></table></figure><ol start="3"><li>下载<code>petalinux2022.2</code>安装包</li></ol><p>地址：<a href="https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/embedded-design-tools.html">Downloads (xilinx.com)</a></p><ol start="4"><li>更改默认shell</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash<br></code></pre></td></tr></table></figure><ol start="5"><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./petalinux-v2022.2-10141622-installer.run -d ./petalinux2022.2<br></code></pre></td></tr></table></figure><p>安装过程需要同意许可信息，输入三次y。</p><h1 id="qemu启动"><a href="#qemu启动" class="headerlink" title="qemu启动"></a>qemu启动</h1><p>参考《ug1144-petalinux-tools-reference-guide.pdf》</p><h2 id="1-生成-BIN镜象"><a href="#1-生成-BIN镜象" class="headerlink" title="1. 生成.BIN镜象"></a>1. 生成.BIN镜象</h2><p>粘贴相应的<code>.bit</code>至<code>plnx-proj-root/images/linux/</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> &lt;plnx-proj-root&gt;<br>petalinux-package --boot --format BIN --fsbl --u-boot --pmufw --fpga ./images/linux/design_1_wrapper.bit --force<br></code></pre></td></tr></table></figure><h2 id="2-封装预构建镜像"><a href="#2-封装预构建镜像" class="headerlink" title="2. 封装预构建镜像"></a>2. 封装预构建镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">petalinux-package --prebuilt --fpga ./images/linux/design_1_wrapper.bit --force<br></code></pre></td></tr></table></figure><h2 id="3-启动qemu"><a href="#3-启动qemu" class="headerlink" title="3. 启动qemu"></a>3. 启动qemu</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">petalinux-boot --qemu --prebuilt 3<br></code></pre></td></tr></table></figure><p>注意：若使用<code>petalinux2021</code>启动qemu需要在xilinx官网下载某个版本的<code>.bsp</code>，将其中的<code>pmu_rom_qemu_sha3.elf</code> 拷贝到<code>&lt;plnx-proj-root&gt;/pre-built/linux/images</code>下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">eddy@eddy:~/code/test$ petalinux-boot --qemu --prebuilt 3<br>[INFO] Sourcing buildtools<br>INFO: No DTB has been specified, use the default one <span class="hljs-string">&quot;/home/eddy/code/test/pre-built/linux/images/system.dtb&quot;</span>.<br>INFO: No DTB has been specified, use the default one <span class="hljs-string">&quot;/home/eddy/code/test/pre-built/linux/images/system.dtb&quot;</span>.<br>INFO: Starting microblaze QEMU<br>INFO: Starting the above QEMU <span class="hljs-built_in">command</span> <span class="hljs-keyword">in</span> the background<br>INFO:  qemu-system-microblazeel -M microblaze-fdt   -serial mon:stdio -serial /dev/null -display none -kernel /home/eddy/code/test/pre-built/linux/images/pmu_rom_qemu_sha3.elf -device loader,file=/home/eddy/code/test/pre-built/linux/images/pmufw.elf      -hw-dtb /home/eddy/code/test/pre-built/linux/images/zynqmp-qemu-multiarch-pmu.dtb -machine-path /tmp/tmp.zRXyRZk5bx -device loader,addr=0xfd1a0074,data=0x1011003,data-len=4 -device loader,addr=0xfd1a007C,data=0x1010f03,data-len=4<br>qemu-system-microblazeel: Failed to connect socket /tmp/tmp.zRXyRZk5bx/qemu-rport-_pmu@0: No such file or directory<br>qemu-system-microblazeel: info: QEMU waiting <span class="hljs-keyword">for</span> connection on: disconnected:unix:/tmp/tmp.zRXyRZk5bx/qemu-rport-_pmu@0,server<br>INFO: TCP PORT is free<br>INFO: Starting aarch64 QEMU<br>INFO:  qemu-system-aarch64 -M arm-generic-fdt   -serial /dev/null -serial mon:stdio -display none -device loader,file=/home/eddy/code/test/pre-built/linux/images/bl31.elf,cpu-num=0 -device loader,file=/home/eddy/code/test/pre-built/linux/images/rootfs.cpio.gz.u-boot,addr=0x04000000,force-raw -device loader,file=/home/eddy/code/test/pre-built/linux/images/u-boot.elf -device loader,file=/home/eddy/code/test/pre-built/linux/images/Image,addr=0x00200000,force-raw -device loader,file=/home/eddy/code/test/pre-built/linux/images/system.dtb,addr=0x00100000,force-raw -device loader,file=/home/eddy/code/test/pre-built/linux/images/boot.scr,addr=0x20000000,force-raw -gdb tcp::9000   -net nic,netdev=eth0 -netdev user,<span class="hljs-built_in">id</span>=eth0,tftp=/tftpboot -net nic -net nic -net nic -net nic   -hw-dtb /home/eddy/code/test/pre-built/linux/images/zynqmp-qemu-multiarch-arm.dtb -machine-path /tmp/tmp.zRXyRZk5bx -global xlnx,zynqmp-boot.cpu-num=0 -global xlnx,zynqmp-boot.use-pmufw=<span class="hljs-literal">true</span>   -m 4G<br>QEMU 5.1.0 monitor - <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;help&#x27;</span> <span class="hljs-keyword">for</span> more information<br>(qemu) qemu-system-aarch64: warning: hub port hub0port3 has no peer<br>qemu-system-aarch64: warning: hub 0 is not connected to host network<br>qemu-system-aarch64: warning: netdev hub0port3 has no peer<br>qemu-system-aarch64: warning: requested NIC (__org.qemu.net4, model unspecified) was not created (not supported by this machine?)<br>PMU Firmware 2021.1Jun  6 2021   07:07:32<br>PMU_ROM Version: xpbr-v8.1.0-0<br>NOTICE:  ATF running on XCZUUNKN/QEMU v4/RTL0.0 at 0xfffea000<br>NOTICE:  BL31: v2.4(release):xlnx_rebase_v2.4_2021.1_update1<br>NOTICE:  BL31: Built : 08:27:07, Apr 28 2021<br><br></code></pre></td></tr></table></figure><h2 id="打包BSP"><a href="#打包BSP" class="headerlink" title="打包BSP"></a>打包BSP</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">petalinux-package --bsp -p 2021-25-mcdma/ --hwsource eth_25g_2021-3-8/ -o 2021-25-mcdma.bsp --force<br></code></pre></td></tr></table></figure><p><code>psu_init</code> 是FSBL中的一个函数，用于初始化PS端</p><h1 id="petalinux-qemu-调试linux内核"><a href="#petalinux-qemu-调试linux内核" class="headerlink" title="petalinux qemu 调试linux内核"></a>petalinux qemu 调试linux内核</h1><ol><li><p>启动<code>qemu</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">petalinux-boot --qemu --prebuilt 3<br></code></pre></td></tr></table></figure></li><li><p>进入<code>&lt;plnx-proj-root&gt;image/linux</code>文件夹</p></li><li><p>进行<code>gdb</code>调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash'">petalinux-util --gdb vmlinux<br></code></pre></td></tr></table></figure></li></ol><p><a href="https://wenfh2020.com/2021/05/19/gdb-kernel-networking/">gdb 调试 Linux 内核网络源码（附视频） (wenfh2020.com)</a></p><h2 id="调试步骤-6"><a href="#调试步骤-6" class="headerlink" title="调试步骤[6]"></a>调试步骤<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[petalinux调试内核_StarLish0715的博客-CSDN博客](https://blog.csdn.net/baidu_37503452/article/details/80106440)">[6]</span></a></sup></h2><p>可参考《ug1144-petalinux-tools-reference-guide.pdf》 Debugging节</p><ol><li><p>启动qemu</p></li><li><p>执行gdb调试命令</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">petalinux-util --gdb vmlinux<br></code></pre></td></tr></table></figure><h1 id="创建zynqMP自定义工程-1"><a href="#创建zynqMP自定义工程-1" class="headerlink" title="创建zynqMP自定义工程[1]"></a>创建<code>zynqMP</code>自定义工程<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[PetaLinux - Public Docs - Trenz Electronic Wiki (trenz-electronic.de)](https://wiki.trenz-electronic.de/display/PD/PetaLinux) petalinux工程创建等使用">[1]</span></a></sup></h1><h2 id="创建-xsa文件"><a href="#创建-xsa文件" class="headerlink" title="创建.xsa文件"></a>创建<code>.xsa</code>文件</h2><p>使用<code>Vivado</code>创建工程并生成<code>xsa</code>文件</p><h2 id="创建自定义工程"><a href="#创建自定义工程" class="headerlink" title="创建自定义工程"></a>创建自定义工程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">petalinux-create -t project --template zynqMP --name &lt;name&gt;<br></code></pre></td></tr></table></figure><h2 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> &lt;plnx-proj-root&gt;<br>petalinux-config --get-hw-description &lt;name&gt;.xsa<br><br>petalinux-config<br><span class="hljs-comment">#默认配置</span><br><br>petalinux-config -c kernel<br><span class="hljs-comment">#配置内核</span><br><br>petalinux-config -c rootfs<br><span class="hljs-comment">#配置文件系统</span><br><br>petalinux-config -c u-boot<br><span class="hljs-comment">#配置u-boot</span><br></code></pre></td></tr></table></figure><p>对构建的工程进行实际的配置</p><h3 id="配置启动地址信息"><a href="#配置启动地址信息" class="headerlink" title="配置启动地址信息"></a>配置启动地址信息</h3><p>进入<code>u-boot Configuration  ---&gt;</code> <code>u-boot script configuration  ---&gt;</code>根据启动方式以及各文件大小进行配置。</p><p><img src="/image/petalinux/image-20230516202016744.png" alt="image-20230516202016744"></p><h2 id="工程编译"><a href="#工程编译" class="headerlink" title="工程编译"></a>工程编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> &lt;plnx-proj-root&gt;<br>petalinux-build<br><span class="hljs-comment">#整个工程编译，编译后生成image.ub</span><br><br>petalinux-build -c kernel<br><span class="hljs-comment">#编译内核</span><br><br>petalinux-build -c rootfs<br><span class="hljs-comment">#编译文件系统</span><br><br>petalinux-build -c u-boot<br><span class="hljs-comment">#编译u-boot</span><br><br>petalinux-build -x distclean<br><span class="hljs-comment">#清空编译后产生的临时文件和下载的sstate cache文件</span><br><br>petalinux-build -x mrproper<br><span class="hljs-comment">#清空所有的临时文件，&lt;PROJECT&gt;/images/,  &lt;PROJECT&gt;/build/  and &lt;PROJECT&gt;/components/plnx_workspace/ directories</span><br><br><br><span class="hljs-string">&quot;petalinux-build -x package&quot;</span> 是 PetaLinux 工具的命令，它用于构建 PetaLinux 项目。PetaLinux 是一个用于嵌入式设备的 Linux 发行版，由 Xilinx 公司开发。PetaLinux 提供了一些工具和命令，用于构建、调试和定制 Linux 系统。其中 <span class="hljs-string">&quot;petalinux-build&quot;</span> 就是用于构建 PetaLinux 项目的命令，而 <span class="hljs-string">&quot;-x package&quot;</span> 则表示只构建指定的软件包。<br><br><span class="hljs-comment">#打包到image.ub</span><br><br>petalinux-build -c mymodule -x do_cleansstate<br><span class="hljs-comment">#清除用户模块</span><br></code></pre></td></tr></table></figure><h3 id="离线编译工程配置"><a href="#离线编译工程配置" class="headerlink" title="离线编译工程配置"></a>离线编译工程配置</h3><p>下载离线包<a href="https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/embedded-design-tools/archive.html">Downloads (xilinx.com)</a></p><p><img src="/image/petalinux/image-20230516163136806.png" alt="image-20230516163136806"></p><p>下载上述两个压缩包。</p><p>当前环境为 petalinux2021.1 设备为<code>250soc</code> （xilinx ）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> &lt;plnx-proj-root&gt;<br>petalinux-config --get-hw-description &lt;name&gt;.xsa<br></code></pre></td></tr></table></figure><p>进入<code>Linux Components Selection</code>  —&gt; <code>u-boot（u-boot-xlinx）</code>以及<code>linux-kernel</code>均选择<code>ext-local-src</code>，配置离线编译包。</p><p><img src="/image/petalinux/image-20230516155842635.png" alt="image-20230516155842635"></p><p><img src="/image/petalinux/image-20230516160123087.png" alt="image-20230516160123087"></p><p><img src="/image/petalinux/image-20230516160222677.png" alt="image-20230516160222677"></p><p>进入<code>Subsystem AUTO Hardware Settings  ---&gt;</code> <code>Serial Settings  ---&gt;</code> 将串口均选择为<code>psu_uart_1</code></p><p><img src="/image/petalinux/image-20230516160245000.png" alt="image-20230516160245000"></p><p>原因是根据<code>.xsa</code>生成的设备树中将<code>uart1</code>配到了设备的<code>serial0</code>。</p><p><img src="/image/petalinux/image-20230516160555650.png" alt="image-20230516160555650"></p><p>若要使用<code>qemu</code>启动，此步骤可空过，若使用板子启动需要将这里的<code>INITRAMFS/INITRD Image name</code>更改为如下<code>petalinux-image-minimal</code>，若更改后使用qemu启动会出现<a href="#dev">ERROR &#x2F;dev</a>的错误。</p><p><img src="/image/petalinux/image-20230516160724405.png" alt="image-20230516160724405"></p><p>配置离线包</p><p>进入<code>Yocto Settings  ---&gt;</code> <code>Add pre-mirror url   ---&gt; </code> 更改为下载的离线包的位置</p><p><img src="/image/petalinux/image-20230516161519634.png" alt="image-20230516161519634"></p><p>注意：这里需要在最前面加上<code>file://</code>。</p><p>配置<code>sstate</code>：</p><p><img src="/image/petalinux/image-20230516161650342.png" alt="image-20230516161650342"></p><p>其他配置可根据情况修改。推出前需保存。</p><p>注意：若中途需要远程下载相应的app或者包文件，需要是能开启<code>Enable Network sstate feeds</code>。防止编译报错。</p><p>若存在<code>app</code>或<code>packages</code>，需要进入文件系统配置中添加相应的选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">petalinux-config -c rootfs<br></code></pre></td></tr></table></figure><p><img src="/image/petalinux/image-20230516161900744.png" alt="image-20230516161900744"></p><p>进入<code>build/conf</code>编辑<code>local.conf</code></p><p><img src="/image/petalinux/image-20230516163537432.png" alt="image-20230516163537432"></p><p>配置完成后若想加<code>app</code>或者<code>packages</code>，需要在<code>project-spec</code>对应的<code>mate-user</code>中添加自己的文件，或有现成的<code>mate-user</code>，直接将此文件夹进行替换即可。</p><p>配置完成后即可进行编译。</p><h2 id="创建自定义模块"><a href="#创建自定义模块" class="headerlink" title="创建自定义模块"></a>创建自定义模块</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> &lt;plnx-proj-root&gt;<br>petalinux-create -t modules --name &lt;user-module-name&gt; --<span class="hljs-built_in">enable</span><br><br>petalinux-create -t apps --template c --name myapp --<span class="hljs-built_in">enable</span><br></code></pre></td></tr></table></figure><h1 id="JTAG烧写"><a href="#JTAG烧写" class="headerlink" title="JTAG烧写"></a>JTAG烧写</h1><h2 id="tcl文件"><a href="#tcl文件" class="headerlink" title=".tcl文件"></a><code>.tcl</code>文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#connect</span><br>fpga -no-revision-check -f design_1_wrapper.bit<br>after 2000<br>targets -<span class="hljs-built_in">set</span> -filter &#123;name =~ <span class="hljs-string">&quot;PSU&quot;</span>&#125;<br>mask_write 0xFFCA0038 0x1C0 0x1C0<br>after 500<br><span class="hljs-comment">#Load and run PMUFW</span><br>targets -<span class="hljs-built_in">set</span> -filter &#123;name =~ <span class="hljs-string">&quot;MicroBlaze PMU&quot;</span>&#125;<br>dow pmu-firmware-250soc-zynqmp.elf<br>con<br>after 500<br><span class="hljs-comment">#Reset A53, load and run FSBL</span><br>targets -<span class="hljs-built_in">set</span> -filter &#123;name =~ <span class="hljs-string">&quot;PS8&quot;</span> || name =~ <span class="hljs-string">&quot;PSU&quot;</span>&#125;<br>mwr 0xffff0000 0x14000000;mask_write 0xFD1A0104 0x501 0x0<br>targets -<span class="hljs-built_in">set</span> -filter &#123;name =~ <span class="hljs-string">&quot;Cortex-A53 #0&quot;</span>&#125;<br><span class="hljs-built_in">source</span> psu_init.tcl<br>dow fsbl-250soc-zynqmp.elf<br>con<br><span class="hljs-comment">#Give FSBL time to run</span><br>after 5000<br>stop<br>psu_ps_pl_isolation_removal; psu_ps_pl_reset_config<br>after 500<br>dow u-boot.elf<br>after 500<br>dow arm-trusted-firmware.elf<br>after 500<br>con<br>after 2000<br>dow -data image.ub 0x8000000<br><br></code></pre></td></tr></table></figure><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="boot-src文件"><a href="#boot-src文件" class="headerlink" title="boot.src文件"></a><code>boot.src</code>文件</h2><p><code>boot.src</code> 文件是一个包含启动指令的文本文件，用于在 U-Boot 环境中设置启动选项和执行启动操作。该文件通常包含一些环境变量设置、内存和设备初始化、加载内核映像和设备树文件等操作。</p><p><code>connfig</code>文件启动地址信息相关配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#</span><br><span class="hljs-comment"># JTAG/DDR image offsets</span><br><span class="hljs-comment">#</span><br>CONFIG_SUBSYSTEM_UBOOT_DEVICETREE_OFFSET=0x100000<br>CONFIG_SUBSYSTEM_UBOOT_KERNEL_OFFSET=0x200000<br>CONFIG_SUBSYSTEM_UBOOT_RAMDISK_IMAGE_OFFSET=0x4000000<br>CONFIG_SUBSYSTEM_UBOOT_FIT_IMAGE_OFFSET=0x10000000<br><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># QSPI/OSPI image offsets</span><br><span class="hljs-comment">#</span><br>CONFIG_SUBSYSTEM_UBOOT_QSPI_KERNEL_OFFSET=0xF00000<br>CONFIG_SUBSYSTEM_UBOOT_QSPI_KERNEL_SIZE=0x1D00000<br>CONFIG_SUBSYSTEM_UBOOT_QSPI_RAMDISK_OFFSET=0x4000000<br>CONFIG_SUBSYSTEM_UBOOT_QSPI_RAMDISK_SIZE=0x4000000<br>CONFIG_SUBSYSTEM_UBOOT_QSPI_FIT_IMAGE_OFFSET=0xF40000<br>CONFIG_SUBSYSTEM_UBOOT_QSPI_FIT_IMAGE_SIZE=0x6400000<br><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># NAND image offsets</span><br><span class="hljs-comment">#</span><br>CONFIG_SUBSYSTEM_UBOOT_NAND_KERNEL_OFFSET=0x4100000<br>CONFIG_SUBSYSTEM_UBOOT_NAND_KERNEL_SIZE=0x3200000<br>CONFIG_SUBSYSTEM_UBOOT_NAND_RAMDISK_OFFSET=0x7800000<br>CONFIG_SUBSYSTEM_UBOOT_NAND_RAMDISK_SIZE=0x3200000<br>CONFIG_SUBSYSTEM_UBOOT_NAND_FIT_IMAGE_OFFSET=0x4180000<br>CONFIG_SUBSYSTEM_UBOOT_NAND_FIT_IMAGE_SIZE=0x6400000<br>CONFIG_SUBSYSTEM_UBOOT_KERNEL_IMAGE=<span class="hljs-string">&quot;Image&quot;</span><br>CONFIG_SUBSYSTEM_UBOOT_FIT_IMAGE=<span class="hljs-string">&quot;image.ub&quot;</span><br><span class="hljs-comment"># CONFIG_SUBSYSTEM_UBOOT_EXT_DTB is not set</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&#x27;V\8i+M\9B\9E\F0\00\00\E2\00\00\00\00\00\00\00\00\85w\9Cr\00Boot script\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\DA\00\00\00\00# This is a boot script for U-Boot</span><br><span class="hljs-string"># Generate boot.scr:</span><br><span class="hljs-string"># mkimage -c none -A arm -T script -d boot.cmd.default boot.scr</span><br><span class="hljs-string">#</span><br><span class="hljs-string">################</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">for boot_target in $&#123;boot_targets&#125;;</span><br><span class="hljs-string">do</span><br><span class="hljs-string">echo &quot;Trying to load boot images from $&#123;boot_target&#125;&quot;</span><br><span class="hljs-string">if test &quot;$&#123;boot_target&#125;&quot; = &quot;jtag&quot; ; then</span><br><span class="hljs-string">booti 0x00200000 0x04000000 0x00100000</span><br><span class="hljs-string">fi</span><br><span class="hljs-string">if test &quot;$&#123;boot_target&#125;&quot; = &quot;mmc0&quot; || test &quot;$&#123;boot_target&#125;&quot; = &quot;mmc1&quot; ; then</span><br><span class="hljs-string">if test -e $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; /uEnv.txt; then</span><br><span class="hljs-string">fatload $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; 0x00200000 uEnv.txt;</span><br><span class="hljs-string">echo &quot;Importing environment(uEnv.txt) from $&#123;boot_target&#125;...&quot;</span><br><span class="hljs-string">env import -t 0x00200000 $filesize</span><br><span class="hljs-string">if test -n $uenvcmd; then</span><br><span class="hljs-string">echo &quot;Running uenvcmd ...&quot;;</span><br><span class="hljs-string">run uenvcmd;</span><br><span class="hljs-string">fi</span><br><span class="hljs-string">fi</span><br><span class="hljs-string">if test -e $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; /image.ub; then</span><br><span class="hljs-string">fatload $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; 0x10000000 image.ub;</span><br><span class="hljs-string">bootm 0x10000000;</span><br><span class="hljs-string">                fi</span><br><span class="hljs-string">if test -e $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; /Image; then</span><br><span class="hljs-string">fatload $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; 0x00200000 Image;;</span><br><span class="hljs-string">fi</span><br><span class="hljs-string">if test -e $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; /system.dtb; then</span><br><span class="hljs-string">fatload $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; 0x00100000 system.dtb;</span><br><span class="hljs-string">fi</span><br><span class="hljs-string">if test -e $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; /ramdisk.cpio.gz.u-boot &amp;&amp; test &quot;$&#123;skip_tinyramdisk&#125;&quot; != &quot;yes&quot;; then</span><br><span class="hljs-string">fatload $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; 0x04000000 ramdisk.cpio.gz.u-boot;</span><br><span class="hljs-string">booti 0x00200000 0x04000000 0x00100000</span><br><span class="hljs-string">fi</span><br><span class="hljs-string">if test -e $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; /rootfs.cpio.gz.u-boot &amp;&amp; test &quot;$&#123;skip_ramdisk&#125;&quot; != &quot;yes&quot;; then</span><br><span class="hljs-string">fatload $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; 0x04000000 rootfs.cpio.gz.u-boot;</span><br><span class="hljs-string">booti 0x00200000 0x04000000 0x00100000</span><br><span class="hljs-string">fi</span><br><span class="hljs-string">booti 0x00200000 - 0x00100000</span><br><span class="hljs-string">fi</span><br><span class="hljs-string">if test &quot;$&#123;boot_target&#125;&quot; = &quot;xspi0&quot; || test &quot;$&#123;boot_target&#125;&quot; = &quot;qspi&quot; || test &quot;$&#123;boot_target&#125;&quot; = &quot;qspi0&quot;; then</span><br><span class="hljs-string">sf probe 0 0 0;</span><br><span class="hljs-string">sf read 0x10000000 0xF40000 0x6400000</span><br><span class="hljs-string">bootm 0x10000000;</span><br><span class="hljs-string">echo &quot;Booting using Fit image failed&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">sf read 0x00200000 0xF00000 0x1D00000</span><br><span class="hljs-string">sf read 0x04000000 0x4000000 0x4000000</span><br><span class="hljs-string">booti 0x00200000 0x04000000 0x00100000;</span><br><span class="hljs-string">echo &quot;Booting using Separate images failed&quot;</span><br><span class="hljs-string">fi</span><br><span class="hljs-string">if test &quot;$&#123;boot_target&#125;&quot; = &quot;nand&quot; || test &quot;$&#123;boot_target&#125;&quot; = &quot;nand0&quot;; then</span><br><span class="hljs-string">nand info;</span><br><span class="hljs-string">nand read 0x10000000 0x4180000 0x6400000</span><br><span class="hljs-string">bootm 0x10000000;</span><br><span class="hljs-string">echo &quot;Booting using Fit image failed&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">nand read 0x00200000 0x4100000 0x3200000</span><br><span class="hljs-string">nand read 0x04000000 0x7800000 0x3200000</span><br><span class="hljs-string">booti 0x00200000 0x04000000 0x00100000;</span><br><span class="hljs-string">echo &quot;Booting using Separate images failed&quot;</span><br><span class="hljs-string">fi</span><br><span class="hljs-string">done</span><br></code></pre></td></tr></table></figure><h2 id="petalinux-2022-2编译工程，显示bitbake版本不兼容-2"><a href="#petalinux-2022-2编译工程，显示bitbake版本不兼容-2" class="headerlink" title="petalinux 2022.2编译工程，显示bitbake版本不兼容[2]"></a>petalinux 2022.2编译工程，显示bitbake版本不兼容<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[PetaLinux Yocto Tips - Xilinx Wiki - Confluence (atlassian.net)](https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842475/PetaLinux+Yocto+Tips) Yocto相关使用">[2]</span></a></sup></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$PETALINUX</span>/components/yocto/buildtools/sysroots/x86_64-petalinux-linux/usr/bin/python3 ./components/yocto/layers/core/scripts/contrib/convert-overrides.py ./project-spec/meta-user/<br></code></pre></td></tr></table></figure><p>错误<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Linux AXI Ethernet driver - Xilinx Wiki - Confluence (atlassian.net)](https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842485/Linux+AXI+Ethernet+driver) Xlinx-AXI-Ethernet-driver相关说明">[5]</span></a></sup></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[   52.763091] alloc_netdev: Unable to allocate device with zero queues<br>[   52.793075] xilinx_axienet: probe of a0010000.ethernet failed with error -12<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">25g-3-6$ petalinux-config --get-hw-description eth25g_wrapper.xsa<br>[INFO] Sourcing buildtools<br>INFO: Getting hardware description...<br>INFO: Renaming eth25g_wrapper.xsa to system.xsa<br>[INFO] Generating Kconfig <span class="hljs-keyword">for</span> project<br>ERROR: Failed to generate /home/pdc/00-petalinux-workspace/25g-3-6/build/misc/config/Kconfig.syshw<br>ERROR: Failed to Kconfig project<br>ERROR: Failed to generate System hardware Kconfig file.<br></code></pre></td></tr></table></figure><p>解决方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install libtinfo5<br></code></pre></td></tr></table></figure><h2 id="ERROR-x2F-dev"><a href="#ERROR-x2F-dev" class="headerlink" title="ERROR &#x2F;dev "></a>ERROR &#x2F;dev <a name="dev"/></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ERROR: There<span class="hljs-string">&#x27;s no &#x27;</span>/dev<span class="hljs-string">&#x27; on rootfs</span><br></code></pre></td></tr></table></figure><p><a href="https://support.xilinx.com/s/question/0D52E00006hprw1SAA/error-theres-no-dev-on-rootfs?language=en_US">ERROR: There’s no ‘&#x2F;dev’ on rootfs (xilinx.com)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">petalinux-config -&gt; Image packaging configuration -&gt; INITRAMFS/INITRD Image name -&gt; petalinux-image-minimal<br></code></pre></td></tr></table></figure><h2 id="指定源码路径"><a href="#指定源码路径" class="headerlink" title="指定源码路径"></a>指定源码路径</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> substitute-path &lt;当前搜索路径&gt; &lt;指的搜索路径&gt;<br><span class="hljs-built_in">set</span> substitute-path /usr/src/kernel /opt/linux-xlnx-xilinx-v2021.1<br></code></pre></td></tr></table></figure><h2 id="打包BOOT-BIN出现Section-image-ub-0-offset-of-0x242C0-overlaps-with-prior-section-end-address-of-242C0C0"><a href="#打包BOOT-BIN出现Section-image-ub-0-offset-of-0x242C0-overlaps-with-prior-section-end-address-of-242C0C0" class="headerlink" title="打包BOOT.BIN出现Section image.ub.0 offset of 0x242C0 overlaps with prior section end address of 242C0C0"></a>打包<code>BOOT.BIN</code>出现<code>Section image.ub.0 offset of 0x242C0 overlaps with prior section end address of 242C0C0</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">***** Xilinx Bootgen v2021.1<br>  **** Build <span class="hljs-built_in">date</span> : May 28 2021-21:36:22<br>    ** Copyright 1986-2021 Xilinx, Inc. All Rights Reserved.<br><br>[ERROR]  : Section image.ub.0 offset of 0x242C0 overlaps with prior section end address of 242C0C0<br>ERROR: Fail to create BOOT image<br></code></pre></td></tr></table></figure><p>指定<code>kernel</code>的<code>offset</code>地址:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">petalinux-package --boot --format BIN --kernel --offset 0x0242d000 --fsbl --u-boot --pmufw --fpga ./images/linux/design_1_wrapper.bit --force<br></code></pre></td></tr></table></figure><h2 id="qspi启动后无法自动跳转至kernel"><a href="#qspi启动后无法自动跳转至kernel" class="headerlink" title="qspi启动后无法自动跳转至kernel"></a><code>qspi</code>启动后无法自动跳转至<code>kernel</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#flash读取至ddr    目的地址   kernel源地址   长度</span><br><span class="hljs-variable">$zynqMP</span>:sf <span class="hljs-built_in">read</span> 0x80000000 0x0242d000 0x2800000<br><br><span class="hljs-variable">$zynqMP</span>:booti 0x80000000<br></code></pre></td></tr></table></figure><h2 id="fit-image"><a href="#fit-image" class="headerlink" title="fit image"></a>fit image</h2><p><img src="/image/petalinux/image-20230516202406387.png" alt="image-20230516202406387"></p><p>在 Petalinux 配置中，QSPI&#x2F;OSPI FIT 映像是指在 QSPI&#x2F;OSPI NOR Flash 上存储的 FIT 映像。FIT 映像是一种灵活的引导映像格式，可以包含多个镜像文件（如内核、设备树、文件系统等），并且可以根据需要进行配置。</p><p>根据上述文件在uboot阶段可以使用以下代码启动<code>kernel</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$zynqMP</span>:sf <span class="hljs-built_in">read</span> 0x10000000 0xF40000 0x6400000<br><span class="hljs-variable">$zynqMP</span>:bootm 0x10000000<br></code></pre></td></tr></table></figure><h1 id="如何修改设备树-3"><a href="#如何修改设备树-3" class="headerlink" title="如何修改设备树[3]"></a>如何修改设备树<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Xilinx Petalinux工程设备树介绍](https://support.xilinx.com/s/article/1197597?language=zh_CN)">[3]</span></a></sup></h1><h2 id="基于自动生成的设备树，添加或修改节点"><a href="#基于自动生成的设备树，添加或修改节点" class="headerlink" title="基于自动生成的设备树，添加或修改节点"></a>基于自动生成的设备树，添加或修改节点</h2><p>通过修改<code>./project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dtsi</code>，来实现对之前已经定义的设备树节点中的属性进行变更，也可以添加没有自动生成的设备树节点。</p><p>设备树语法可参考 《devicetree-specification.pdf》<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Releases · devicetree-org/devicetree-specification (github.com)](https://github.com/devicetree-org/devicetree-specification/releases?page=2)">[4]</span></a></sup></p><p>设备树更改完成后需要执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">petalinux-build -c device-tree -x cleansstate<br>生成pl.dtsi<br>petalinux-config -c device-tree<br>petalinux-build -c device-tree<br></code></pre></td></tr></table></figure><h2 id="设备树反编译"><a href="#设备树反编译" class="headerlink" title="设备树反编译"></a>设备树反编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> &lt;plnx-proj-root&gt;/images/linux/<br>../../build/tmp/sysroots-components/x86_64/dtc-native/usr/bin/dtc -I dtb -O dts -o system.dts system.dtb<br></code></pre></td></tr></table></figure><h1 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h1><p>PG332 ERNIC 手册</p><p>PG203 CMAC 手册</p><p>PG210 25G AXI Ethernet 手册</p><p>PG021 AXI-DMA手册</p><p>PG288 MCDMA手册</p><p>UG1085-Zynq-Ultrascale-trm 手册 250 SoC芯片手册</p><p><a href="https://www.xilinx.com/htmldocs/registers/ug1087/ug1087-zynq-ultrascale-registers.html">Zynq UltraScale+ Devices Register Reference (xilinx.com)</a> ug1085-Zynq-Ultrascale寄存器手册</p><p>UG1144 Petalinux Tools手册</p><p>错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">RROR: perftest-1.0-r0 do_compile: oe_runmake failed<br>ERROR: perftest-1.0-r0 do_compile: Execution of <span class="hljs-string">&#x27;/home/dpu/zjzhe/250soc_ernic/build/tmp/work/cortexa72-cortexa53-xilinx-linux/perftest/1.0-r0/temp/run.do_compile.180753&#x27;</span> failed with <span class="hljs-built_in">exit</span> code 1:<br>make  all-am<br>make[1]: Entering directory <span class="hljs-string">&#x27;/home/dpu/zjzhe/250soc_ernic/build/tmp/work/cortexa72-cortexa53-xilinx-linux/perftest/1.0-r0/git&#x27;</span><br>make[1]: *** No rule to make target <span class="hljs-string">&#x27;../../../umm/1.0-r0/libumm.so&#x27;</span>, needed by <span class="hljs-string">&#x27;libperftest.a&#x27;</span>.  Stop.<br><br></code></pre></td></tr></table></figure><p>解决方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpu@dpu-PC:~/zjzhe/250soc_ernic/build/tmp/work/cortexa72-cortexa53-xilinx-linux/perftest/1.0-r0/git$ find ..// -name <span class="hljs-string">&quot;libumm*&quot;</span><br>..//recipe-sysroot/usr/lib/libumm.so.1.0<br>..//recipe-sysroot/usr/lib/libumm.so.1<br>..//recipe-sysroot/usr/lib/libumm.so<br>dpu@dpu-PC:~/zjzhe/250soc_ernic/build/tmp/work/cortexa72-cortexa53-xilinx-linux/perftest/1.0-r0$ <span class="hljs-built_in">ln</span> -s ./recipe-sysroot/usr/lib/libumm.so ../../umm/1.0-r0/libumm.so<br><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.zynqnotes.com/pl-ps-interrupt">中断（一）：让 Linux 接收来自 PL 的自定义中断信号 (zynqnotes.com)</a> zynqMP PL2PS、PS2PL设备树中断配置</p><p><a href="https://docs.xilinx.com/">主页 • 文档门户 (xilinx.com)</a> Xlinx 文档下载</p><p><a href="https://github.com/Xilinx/u-boot-xlnx">Xilinx&#x2F;u-boot-xlnx: The official Xilinx u-boot repository (github.com)</a> xlinx维护的uboot</p><p><a href="https://github.com/Xilinx/linux-xlnx">Xilinx&#x2F;linux-xlnx: The official Linux kernel from Xilinx (github.com)</a> xlinx维护的linux</p><p><a href="https://zhuanlan.zhihu.com/p/478422063">Petalinux2020.2 开发ZYNQ的AXI DMA - 知乎 (zhihu.com)</a> petalinux创建modules</p><p><a href="https://www.cnblogs.com/schips/p/xilinx-petalinux-common-commands.html">PetaLinux常用命令汇总 - schips - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/u011529140/article/details/70800460"> petalinux-package qspi启动镜像的问题_uimage_offset_边城1987的博客-CSDN博客</a></p><p><a href="https://support.xilinx.com/s/question/0D52E00006hpeRTSAY/petalinuxpackage-boot-add-offset-doesnt-work-as-before?language=en_US">petalinux-package –boot –add –offset doesn’t work as before (xilinx.com)</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://wiki.trenz-electronic.de/display/PD/PetaLinux">PetaLinux - Public Docs - Trenz Electronic Wiki (trenz-electronic.de)</a> petalinux工程创建等使用<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842475/PetaLinux+Yocto+Tips">PetaLinux Yocto Tips - Xilinx Wiki - Confluence (atlassian.net)</a> Yocto相关使用<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://support.xilinx.com/s/article/1197597?language=zh_CN">Xilinx Petalinux工程设备树介绍</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://github.com/devicetree-org/devicetree-specification/releases?page=2">Releases · devicetree-org&#x2F;devicetree-specification (github.com)</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842485/Linux+AXI+Ethernet+driver">Linux AXI Ethernet driver - Xilinx Wiki - Confluence (atlassian.net)</a> Xlinx-AXI-Ethernet-driver相关说明<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://blog.csdn.net/baidu_37503452/article/details/80106440">petalinux调试内核_StarLish0715的博客-CSDN博客</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>petalinux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>petalinux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式基础</title>
    <link href="/2023/06/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/06/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><strong>正则表达式</strong>是一种用于匹配和操作文本的强大工具，它是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本模式。</p><p>正则表达式可以在文本中查找、替换、提取和验证特定的模式。</p><h3 id="命令行展开"><a href="#命令行展开" class="headerlink" title="命令行展开"></a>命令行展开</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">eddy@DESKTOP-KTLF3P4:~$ <span class="hljs-built_in">echo</span> <span class="hljs-built_in">ls</span>&#123;0..20&#125;<br>ls0 ls1 ls2 ls3 ls4 ls5 ls6 ls7 ls8 ls9 ls10 ls11 ls12 ls13 ls14 ls15 ls16 ls17 ls18 ls19 ls20<br>eddy@DESKTOP-KTLF3P4:~$ <span class="hljs-built_in">echo</span> <span class="hljs-built_in">pwd</span>&#123;1..20..2&#125;<br>pwd1 pwd3 pwd5 pwd7 pwd9 pwd11 pwd13 pwd15 pwd17 pwd19<br>eddy@DESKTOP-KTLF3P4:~$ <span class="hljs-built_in">echo</span> <span class="hljs-built_in">pwd</span>&#123;01..20..2&#125;<br>pwd01 pwd03 pwd05 pwd07 pwd09 pwd11 pwd13 pwd15 pwd17 pwd19<br>eddy@DESKTOP-KTLF3P4:~$<br></code></pre></td></tr></table></figure><h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span>, <span class="hljs-built_in">unalias</span><br>eddy@DESKTOP-KTLF3P4:~$ <span class="hljs-built_in">alias</span> <span class="hljs-built_in">rm</span>=<span class="hljs-string">&#x27;rm -i&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span><br>!&lt;行号&gt;  <span class="hljs-comment">#执行history中第&lt;&gt;条命令</span><br>!! <span class="hljs-comment">#执行上次命令</span><br></code></pre></td></tr></table></figure><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ctrl + a<span class="hljs-comment">#移动到命令行首</span><br>ctrl + e<span class="hljs-comment">#移动到命令行尾</span><br>ctrl + k<span class="hljs-comment">#删除光标后的字符</span><br>ctrl + u<span class="hljs-comment">#删除光标前的内容</span><br></code></pre></td></tr></table></figure><h3 id="查询命令位置"><a href="#查询命令位置" class="headerlink" title="查询命令位置"></a>查询命令位置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><h1 id="Linux正则表达式（Regular-Expression，REGEXP）"><a href="#Linux正则表达式（Regular-Expression，REGEXP）" class="headerlink" title="Linux正则表达式（Regular Expression，REGEXP）"></a>Linux正则表达式（Regular Expression，REGEXP）</h1><ul><li>grep：文本过滤工具，（模式：pattern）</li><li>sed：stream editor，流编辑器；文本编辑器</li><li>awk：Linux的文本报告生成器（格式化文本），Linux中是gawk</li></ul><h2 id="正则表达式的分类"><a href="#正则表达式的分类" class="headerlink" title="正则表达式的分类"></a>正则表达式的分类</h2><ul><li>基本正则表达式（BRE，basic regular exporession）</li></ul><blockquote><p>BRE对应的字符有 ^ $ . [] *</p></blockquote><ul><li>扩展正则表达式（ERE，extended regular expression）</li></ul><blockquote><p>ERE在BRE的基础上增加 () {} ? + | 等字符</p></blockquote><h3 id="基本正则表达式BRE集合"><a href="#基本正则表达式BRE集合" class="headerlink" title="基本正则表达式BRE集合"></a>基本正则表达式BRE集合</h3><ul><li>匹配字符</li><li>匹配次数</li><li>位置锚定</li></ul><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>^</td><td>尖角号，用于模式的最左侧，如”^oldboy”，匹配oldboy单词开头的行</td></tr><tr><td>$</td><td>美元符，用于模式的最右侧，如”oldboy$”，表示以oldboy单词结尾的行</td></tr><tr><td>^$</td><td>组合符，表示空行</td></tr><tr><td>.</td><td>匹配任意一个有且只有一个字符，不能匹配空行</td></tr><tr><td>\</td><td>转义字符，让特殊含义的字符还原本意，例如<code>\.</code>表示小数点</td></tr><tr><td>*</td><td>匹配前一个字符（连续出现）0次或1次以上，重复0次代表空，即匹配所有内容</td></tr><tr><td>.*</td><td>组合符，匹配所有内容</td></tr><tr><td>^.*</td><td>组合符，匹配任意多个字符开头的内容</td></tr><tr><td>.*$</td><td>组合符，匹配任意多个字符结尾的内容</td></tr><tr><td>[abc]</td><td>匹配[]内的任意一个字符，a或b或c，可以写为[a-c]</td></tr><tr><td>[^abc]</td><td>匹配除了^后面的任意字符，a或b或c，^表示对[abc]的取反</td></tr></tbody></table><h3 id="扩展正则表达式ERE集合"><a href="#扩展正则表达式ERE集合" class="headerlink" title="扩展正则表达式ERE集合"></a>扩展正则表达式ERE集合</h3><p>扩展正则表达式必须用<code>grep -E</code>才能生效</p><table><thead><tr><th>字符</th><th>作用</th></tr></thead><tbody><tr><td>+</td><td>匹配前一个字符一次或多次</td></tr><tr><td>[:&#x2F;]+</td><td>匹配<code>[]</code>内的”:”或者”&#x2F;“字符一次或多次</td></tr><tr><td>?</td><td>匹配前一个字符0次或一次</td></tr><tr><td>|</td><td>表示<code>或</code>，同时过滤多个字符串</td></tr><tr><td>()</td><td>分组过滤，被括起来的内容表示一个整体</td></tr><tr><td>a{n,m}</td><td>匹配前一个字符最少<code>n</code>次，最多<code>m</code>次</td></tr><tr><td>a{n,}</td><td>匹配前一个字符最少n次</td></tr><tr><td>a{n}</td><td>匹配前一个字符正好n次</td></tr><tr><td>a{,m}</td><td>匹配前一个字符最多m次</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html">表达式全集</a></p>]]></content>
    
    
    <categories>
      
      <category>正则表达式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
